157 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 901
int passes = 0;
growth = 0;
delta = 0;
passes++;
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
passes, offset + growth, offset, growth);
0

158 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 900
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
0

178 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7175
js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes)
prologCount = cg->prolog.noteCount;
prologCount = cg->prolog.noteCount;
memcpy(notes, cg->prolog.notes, SRCNOTE_SIZE(prologCount));
0

226 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 1000
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd2->offset += delta;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
ptrdiff_t deltaFromTop = 0;
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd->offset += delta;
span = SD_SPAN(sd, pivot);
for (sd = sdbase; sd < sdlimit; sd++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
span = SD_SPAN(sd, pivot);
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
oldpc = base + sd->before;
oldpc + 1 + JUMP_OFFSET_LEN,
0

227 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 1001
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
base = CG_BASE(cg);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
ptrdiff_t deltaFromTop = 0;
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
sd2->offset += delta;
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
incr = BYTECODE_SIZE(length) - size;
JS_ASSERT(sd == sdlimit);
oldpc = base + sd->before;
span = SD_SPAN(sd, pivot);
SET_JUMP_OFFSET(oldpc, span);
delta = offset - sd->before;
oldpc + 1 + JUMP_OFFSET_LEN,
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd->offset += delta;
span = SD_SPAN(sd, pivot);
for (sd = sdbase; sd < sdlimit; sd++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
offset = CG_OFFSET(cg);
passes, offset + growth, offset, growth);
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
size);
0

251 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 3164
js_ReportOutOfScriptQuota(cx);
JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
UpdateDepth(cx, cg, offset);
UpdateDepth(cx, cg, offset);
if (js_LookupLocal(cx, cg->fun, atom, NULL) != JSLOCAL_NONE)
ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &objbox,
ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
OBJ_DROP_PROPERTY(cx, objbox, prop);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
limit = slot + OBJ_BLOCK_COUNT(cx, blockObj);
js_ReallocSlots(cx, blockObj, JSSLOT_FREE(&js_BlockClass), JS_TRUE);
count = OBJ_BLOCK_COUNT(cx, pn2->pn_objbox->object);
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
jsbitmap intmap_space[INTMAP_LENGTH];
atom = js_AtomizeDouble(cx, d);
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
intmap = intmap_space;
* sizeof(jsbitmap));
(JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
intmap_bitlen = INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2;
intmap_bitlen = JS_BIT(16);
(JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
* sizeof(jsbitmap));
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
AdjustBlockSlot(JSContext *cx, JSCodeGenerator *cg, jsint slot)
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
EmitEnterBlock(JSContext *cx, JSParseNode *pn, JSCodeGenerator *cg)
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
EmitSwitch(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
js_Emit1(JSContext *cx, JSCodeGenerator *cg, JSOp op)
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitCheck(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t delta)
ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitObjectOp(JSContext *cx, JSObjectBox *objbox, JSOp op,
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
EmitIndexOp(JSContext *cx, JSOp op, uintN index, JSCodeGenerator *cg)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
EmitBigIndexPrefix(JSContext *cx, JSCodeGenerator *cg, uintN index)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
UpdateDepth(JSContext *cx, JSCodeGenerator *cg, ptrdiff_t target)
UpdateDepth(cx, cg, offset);
UpdateDepth(cx, cg, offset);
js_Emit2(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1)
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
LookupCompileTimeConstant(JSContext *cx, JSCodeGenerator *cg, JSAtom *atom,
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
JS_malloc(cx,
intmap = (jsbitmap *)
memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
0

257 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7113
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('*', fp);
0

258 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7114
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('\n', fp);
0

260 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7116
static FILE *fp;
fp = fopen("/tmp/srcnotes.hist", "w");
setvbuf(fp, NULL, _IONBF, 0);
fprintf(fp, "SrcNote size histogram:\n");
fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
fputc('*', fp);
fputc('\n', fp);
fputc('\n', fp);
0

417 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 999
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
sdbase = cg->spanDeps;
sdlimit = sdbase + cg->numSpanDeps;
offset = CG_OFFSET(cg);
growth = 0;
delta = 0;
JS_ASSERT(JT_HAS_TAG(sd->target));
sd->offset += delta;
sdtop = sd;
top = sd->top;
JS_ASSERT(top == sd->before);
span = SD_SPAN(sd, pivot);
ptrdiff_t deltaFromTop = 0;
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd2->offset += deltaFromTop;
deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
sd2->offset += deltaFromTop;
sd2->offset += delta;
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
growth += delta;
passes, offset + growth, offset, growth);
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
passes, offset + growth, offset, growth);
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
SET_JUMP_OFFSET(oldpc, span);
pc = base + sd->offset;
offset = sd->before + 1;
delta = offset - sd->before;
JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
oldpc + 1 + JUMP_OFFSET_LEN,
memmove(pc + 1 + JUMPX_OFFSET_LEN,
UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
sd = sd2 - 1;
for (sd = sdbase; sd < sdlimit; sd++) {
JS_ASSERT(sd == sdlimit);
span = SD_SPAN(sd, pivot);
oldpc = base + sd->before;
pc = base + sd->offset;
memmove(pc + 1 + JUMPX_OFFSET_LEN,
oldpc + 1 + JUMP_OFFSET_LEN,
memmove(pc + 1 + JUMPX_OFFSET_LEN,
OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
base = CG_BASE(cg);
size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
pc = base + sd->offset;
memmove(pc + 1 + JUMPX_OFFSET_LEN,
0

428 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cfunc 7176
js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes)
JS_ASSERT(cg->current == &cg->main);
prologCount = cg->prolog.noteCount;
prologCount = cg->prolog.noteCount;
mainCount = cg->main.noteCount;
memcpy(notes, cg->prolog.notes, SRCNOTE_SIZE(prologCount));
memcpy(notes + prologCount, cg->main.notes, SRCNOTE_SIZE(mainCount));
SN_MAKE_TERMINATOR(&notes[totalCount]);
memcpy(notes + prologCount, cg->main.notes, SRCNOTE_SIZE(mainCount));
0

626 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp cppfunc 2209
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->lexdeps.count;
vector = (uint32 *) calloc(length, sizeof *vector);
1

14276 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp Buffer_Overflow_boundedcpy 7081
base = CG_BASE(cg);
next = CG_NEXT(cg);
offset = PTRDIFF(next, base, jsbytecode);
js_ReportOutOfScriptQuota(cx);
return -1;
return offset;
pc = CG_CODE(cg, target);
op = (JSOp) *pc;
cs = &js_CodeSpec[op];
extern uint8 js_opcode2extra[];
extra = js_opcode2extra[op];
((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT) +
depth = (uintN) cg->stackDepth +
extra;
depth = (uintN) cg->stackDepth +
cg->maxStackDepth = depth;
nuses = js_GetStackUses(cs, op, pc);
cg->stackDepth -= nuses;
JS_ASSERT(cg->stackDepth >= 0);
JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
ndefs = cs->ndefs;
blockObj = cg->objectList.lastbox->object;
JS_ASSERT(STOBJ_GET_CLASS(blockObj) == &js_BlockClass);
JS_ASSERT(JSVAL_IS_VOID(blockObj->fslots[JSSLOT_BLOCK_DEPTH]));
OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
cg->stackDepth += ndefs;
cg->maxStackDepth = cg->stackDepth;
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, length);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
jt = *jtp;
jt2 = jt->kids[otherDir];
*jtp = root = jt2->kids[dir];
*jtp = root = jt->kids[otherDir];
jt = cg->jtFreeList;
jt->offset = args->offset;
jt->balance = 0;
jt->kids[JT_LEFT] = jt->kids[JT_RIGHT] = NULL;
*jtp = jt;
? 1 - BalanceJumpTargets(jtp)
JS_ASSERT(-1 <= jt->balance && jt->balance <= 1);
JS_ASSERT(jt->balance == rh - lh);
ReportStatementTooLarge(cx, cg);
AddJumpTarget(&args, &cg->jumpTargets);
AVLCheck(cg->jumpTargets);
index = cg->numSpanDeps;
ReportStatementTooLarge(cx, cg);
(!(sdbase = cg->spanDeps) || index >= SPANDEPS_MIN)) {
size = sdbase ? SPANDEPS_SIZE(index) : SPANDEPS_SIZE_MIN / 2;
sdbase = (JSSpanDep *) JS_realloc(cx, sdbase, size + size);
cg->spanDeps = sdbase;
cg->numSpanDeps = index + 1;
sd->top = PTRDIFF(pc, CG_BASE(cg), jsbytecode);
sd->offset = sd->before = PTRDIFF(pc2, CG_BASE(cg), jsbytecode);
ReportStatementTooLarge(cx, cg);
if (!SetSpanDepTarget(cx, cg, sd, off))
if (!AddSpanDep(cx, cg, pc, pc2, off))
pc = AddSwitchSpanDeps(cx, cg, pc);
if (!AddSpanDep(cx, cg, pc, pc, off))
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
ts->filename ? ts->filename : "stdin", cg->firstLine,
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
sd2 = FindNearestSpanDep(cg, target,
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
jmp = js_Emit3(cx, cg, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
pc = CG_CODE(cg, jmp);
if (!AddSpanDep(cx, cg, pc, pc, off))
if (!BuildSpanDepTable(cx, cg))
return SetSpanDepTarget(cx, cg, GetSpanDep(cg, pc), off);
stmt->flags = 0;
stmt->blockid = tc->blockid();
stmt->label = NULL;
JS_ASSERT(!stmt->blockObj);
stmt->down = tc->topStmt;
if (STMT_LINKS_SCOPE(stmt)) {
tc->topScopeStmt = stmt;
stmt->downScope = NULL;
js_PushStatement(tc, stmt, STMT_BLOCK, top);
stmt->flags |= SIF_SCOPE;
stmt->downScope = tc->topScopeStmt;
tc->topScopeStmt = stmt;
depth = cg->stackDepth;
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
if (js_Emit1(cx, cg, JSOP_LEAVEWITH) < 0)
if (js_Emit1(cx, cg, JSOP_ENDITER) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
i = OBJ_BLOCK_COUNT(cx, stmt->blockObj);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
cg->stackDepth = depth;
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
valueAtom = js_AtomizeDouble(cx, dval);
ale = cg->constList.add(cg->compiler, atom);
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &objbox,
ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
OBJ_DROP_PROPERTY(cx, objbox, prop);
} while ((cg = (JSCodeGenerator *) cg->parent) != NULL);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return js_Emit1(cx, cg, JSOP_LENGTH) >= 0;
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
return EmitIndexOp(cx, op, ALE_INDEX(ale), cg);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
JS_ASSERT((jsuint) slot < cg->maxStackDepth);
slot += cg->fun->u.i.nvars;
js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
slot = -1;
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
JSObject *blockObj = pn->pn_objbox->object;
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
limit = slot + OBJ_BLOCK_COUNT(cx, blockObj);
js_ReallocSlots(cx, blockObj, JSSLOT_FREE(&js_BlockClass), JS_TRUE);
JSContext *cx = cg->compiler->context;
uintN upvarLevel = fun->u.i.script->staticLevel;
JSLocalKind localKind = js_LookupLocal(cx, fun, atom, &index);
JS_ASSERT(cg->staticLevel > upvarLevel);
JSAtomListElement *ale = cg->upvarList.lookup(atom);
!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR)) {
ale = cg->upvarList.add(cg->compiler, atom);
JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->upvarMap.length;
JS_ASSERT(ALE_INDEX(ale) <= length);
if (ALE_INDEX(ale) == length) {
length = 2 * JS_MAX(2, length);
vector = (uint32 *) JS_realloc(cx, vector, length * sizeof *vector);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
vector[ALE_INDEX(ale)] = MAKE_UPVAR_COOKIE(skip, index);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = MAKE_UPVAR_COOKIE(cg->staticLevel, ALE_INDEX(ale));
pn->pn_dflags |= PND_BOUND;
JS_ASSERT(pn->pn_type == TOK_NAME);
JS_ASSERT(pn->pn_op != JSOP_ARGUMENTS && pn->pn_op != JSOP_CALLEE);
JS_ASSERT(pn->pn_cookie == FREE_UPVAR_COOKIE);
pn->pn_dflags |= (dn->pn_dflags & PND_CONST);
op = PN_OP(pn);
JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
cookie = dn->pn_cookie;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
pn->pn_op = JSOP_FALSE;
pn->pn_dflags |= PND_BOUND;
if (pn->isConst())
pn->pn_op = op = JSOP_NAME;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
? STOBJ_GET_PARENT(FUN_OBJECT(cg->fun))
return MakeUpvarForEval(pn, cg);
case JSOP_NAME:     op = JSOP_GETGVAR; break;
case JSOP_SETNAME:  op = JSOP_SETGVAR; break;
case JSOP_INCNAME:  op = JSOP_INCGVAR; break;
case JSOP_NAMEINC:  op = JSOP_GVARINC; break;
case JSOP_DECNAME:  op = JSOP_DECGVAR; break;
case JSOP_NAMEDEC:  op = JSOP_GVARDEC; break;
pn->pn_op = op;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
uintN level = UPVAR_FRAME_SKIP(cookie);
JS_ASSERT(cg->staticLevel >= level);
JS_ASSERT(cg->staticLevel >= level);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
return MakeUpvarForEval(pn, cg);
JS_ASSERT(cg->flags & TCF_IN_FUNCTION);
JS_ASSERT(cg->lexdeps.lookup(atom));
if (FUN_FLAT_CLOSURE(cg->fun)) {
op = JSOP_GETDSLOT;
op = JSOP_GETUPVAR;
ale = cg->upvarList.lookup(atom);
index = ALE_INDEX(ale);
if (!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR))
ale = cg->upvarList.add(cg->compiler, atom);
index = ALE_INDEX(ale);
JS_ASSERT(index == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
if (!vector)
uint32 length = cg->lexdeps.count;
vector = (uint32 *) calloc(length, sizeof *vector);
JS_ReportOutOfMemory(cx);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
pn->pn_op = op;
pn->pn_cookie = index;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
case JSOP_NAME:     op = JSOP_GETARG; break;
case JSOP_SETNAME:  op = JSOP_SETARG; break;
case JSOP_INCNAME:  op = JSOP_INCARG; break;
case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
case JSOP_DECNAME:  op = JSOP_DECARG; break;
case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
case JSOP_FORNAME:  op = JSOP_FORARG; break;
JS_ASSERT(!pn->isConst());
JS_ASSERT(op != JSOP_CALLEE);
JS_ASSERT((cg->fun->flags & JSFUN_LAMBDA) && atom == cg->fun->atom);
JS_ASSERT(op != JSOP_DELNAME);
op = JSOP_CALLEE;
pn->pn_dflags |= PND_CONST;
pn->pn_op = op;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
JS_ASSERT(op != PN_OP(pn));
pn->pn_op = op;
pn->pn_cookie = UPVAR_FRAME_SLOT(cookie);
pn->pn_dflags |= PND_BOUND;
JSAtomListElement *ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!EmitIndexOp(cx, JSOP_QNAMEPART, ALE_INDEX(ale), cg))
JS_ASSERT(pn->pn_arity == PN_NAME);
pn2 = pn->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pndown))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
if (!EmitSpecialPropOp(cx, pndot, JSOP_GETELEM, cg))
} else if (!EmitAtomOp(cx, pndot, PN_OP(pndot), cg)) {
if (!js_EmitTree(cx, cg, pn2))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
JSParseNode *left, *right, *next, ltmp, rtmp;
JS_ASSERT(pn->pn_op == JSOP_GETELEM);
JS_ASSERT(pn->pn_count >= 3);
left = pn->pn_head;
right = pn->last();
next = left->pn_next;
JS_ASSERT(next != right);
if (!BindNameToSlot(cx, cg, left))
next = left->pn_next;
JS_ASSERT(next != right || pn->pn_count == 3);
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, next))
left = &ltmp;
JS_ASSERT(ATOM_IS_STRING(pn->pn_atom));
right->pn_op = js_IsIdentifier(ATOM_TO_STRING(pn->pn_atom))
JS_ASSERT(pn->pn_arity == PN_BINARY);
if (!BindNameToSlot(cx, cg, left))
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, right))
return js_Emit1(cx, cg, JSOP_ZERO) >= 0;
return js_Emit1(cx, cg, JSOP_ONE) >= 0;
return js_Emit2(cx, cg, JSOP_INT8, (jsbytecode)(int8)ival) >= 0;
off = js_EmitN(cx, cg, JSOP_UINT24, 3);
pc = CG_CODE(cg, off);
off = js_EmitN(cx, cg, JSOP_INT32, 4);
pc = CG_CODE(cg, off);
atom = js_AtomizeDouble(cx, dval);
ale = cg->atomList.add(cg->compiler, atom);
return EmitIndexOp(cx, JSOP_DOUBLE, ALE_INDEX(ale), cg);
JSStmtInfo *stmtInfo)
count = OBJ_BLOCK_COUNT(cx, pn2->pn_objbox->object);
js_PushBlockScope(cg, stmtInfo, pn2->pn_objbox->object, -1);
stmtInfo->type = STMT_SWITCH;
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
js_PushStatement(cg, stmtInfo, STMT_SWITCH, top);
atom = js_AtomizeDouble(cx, d);
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
atom = js_AtomizeDouble(cx, d);
JS_malloc(cx,
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
JS_free(cx, intmap);
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
if (pn4 && !js_EmitTree(cx, cg, pn4))
if (!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
caseNoteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
off = EmitJump(cx, cg, JSOP_CASE, 0);
noteCount = CG_NOTE_COUNT(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1,
noteCountDelta = CG_NOTE_COUNT(cg) - noteCount;
!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
defaultOffset = EmitJump(cx, cg, JSOP_DEFAULT, 0);
pc = CG_CODE(cg, top + JUMP_OFFSET_LEN);
table = (JSParseNode **) JS_malloc(cx, tableSize);
if (!AddSwitchSpanDeps(cx, cg, CG_CODE(cg, top)))
savepc = CG_NEXT(cg);
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
ok = js_EmitTree(cx, cg, pn4);
off = CG_OFFSET(cg) - top;
ok = js_SetJumpOffset(cx, cg, CG_CODE(cg, defaultOffset),
ok = js_SetJumpOffset(cx, cg, pc, off);
off = CG_OFFSET(cg) - top;
ok = js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, off);
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!UpdateLineNumberNotes(cx, cg, pn->pn_pos.begin.lineno))
CG_SWITCH_TO_MAIN(cg);
if (!emitter(cx, cg, prologOp, pn2))
if (!emitter(cx, cg, prologOp, pn3))
pn = pn->pn_kid;
if (!EmitDestructuringOpsHelper(cx, cg, pn))
if (!BindNameToSlot(cx, cg, pn))
if (pn->isConst() && !pn->isInitialized())
return js_Emit1(cx, cg, JSOP_POP) >= 0;
if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, cg))
if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, cg))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pn))
if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
intN stackDepth = cg->stackDepth;
JS_ASSERT(stackDepth != 0);
if (js_Emit1(cx, cg, JSOP_DUP) < 0)
if (!EmitNumberOp(cx, index, cg))
JS_ASSERT(pn2->pn_type == TOK_COLON);
if (js_NewSrcNote(cx, cg, SRC_INITPROP) < 0)
if (!EmitNumberOp(cx, pn3->pn_dval, cg))
pn3 = pn2->pn_right;
if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
JS_ASSERT(cg->stackDepth == stackDepth + 1);
JS_ASSERT(pn2 == pn3);
for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
pn3 = pn2;
if (!EmitDestructuringLHS(cx, cg, pn3))
JS_ASSERT(cg->stackDepth == stackDepth);
JS_ASSERT(cg->stackDepth == stackDepth + 1);
if (!EmitDestructuringLHS(cx, cg, pn3))
return EmitDestructuringOpsHelper(cx, cg, pn);
depth = limit = (uintN) cg->stackDepth;
if (!js_EmitTree(cx, cg, pn))
i = depth;
JS_ASSERT(i < limit);
jsint slot = AdjustBlockSlot(cx, cg, i);
if (js_Emit1(cx, cg, JSOP_POP) < 0)
if (!EmitDestructuringLHS(cx, cg, pn))
JS_ASSERT(pn->pn_type == TOK_ASSIGN);
JSParseNode *pn, JSOp *pop)
lhs = pn->pn_left;
if (!EmitGroupAssignment(cx, cg, prologOp, lhs, rhs))
JSParseNode *lhs, JSParseNode *rhs)
for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
if (!EmitDestructuringLHS(cx, cg, pn))
off = noteIndex = -1;
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn2))
JS_ASSERT(pn2->pn_left->pn_type == TOK_NAME);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
if (!MaybeEmitGroupAssignment(cx, cg,
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn3))
if (!js_EmitTree(cx, cg, pn2->pn_right))
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!MaybeEmitVarDecl(cx, cg, PN_OP(pn), pn2, &atomIndex))
!js_DefineCompileTimeConstant(cx, cg, pn2->pn_atom, pn3)) {
if (!js_EmitTree(cx, cg, pn3))
js_NewSrcNote2(cx, cg, SRC_DECL,
if (js_Emit1(cx, cg, op) < 0)
tmp = CG_OFFSET(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
index = CG_NOTE_COUNT(cg);
if (((uintN)index & CG_NOTE_MASK(cg)) == 0) {
if (!CG_NOTES(cg)) {
js_ReportOutOfScriptQuota(cx);
return -1;
return index;
index = AllocSrcNote(cx, cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
return -1;
sn = &CG_NOTES(cg)[index];
offset = CG_OFFSET(cg);
delta = offset - CG_LAST_NOTE_OFFSET(cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
index = AllocSrcNote(cx, cg);
return -1;
sn = &CG_NOTES(cg)[index];
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
if (js_NewSrcNote(cx, cg, SRC_NULL) < 0)
return -1;
return index;
index = js_NewSrcNote(cx, cg, type);
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
return -1;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
return index;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
if (!js_SetSrcNoteOffset(cx, cg, index, 1, offset2))
js_ReportOutOfScriptQuota(cx);
sn = &CG_NOTES(cg)[index];
JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
for (sn++; which; sn++, which--) {
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (!GrowSrcNotes(cx, cg))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
if (!EmitDestructuringLHS(cx, cg, pn3))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
sd2 = FindNearestSpanDep(cg, target,
sn += 2;
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
JS_ASSERT(diff >= 0);
memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
1

14277 CVE-2011-0054/Firefox_3.5.16_CVE_2011_0054_js_src_jsemit.cpp Buffer_Overflow_boundedcpy 7081
base = CG_BASE(cg);
next = CG_NEXT(cg);
offset = PTRDIFF(next, base, jsbytecode);
js_ReportOutOfScriptQuota(cx);
return -1;
return offset;
pc = CG_CODE(cg, target);
op = (JSOp) *pc;
cs = &js_CodeSpec[op];
extern uint8 js_opcode2extra[];
extra = js_opcode2extra[op];
((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT) +
depth = (uintN) cg->stackDepth +
extra;
depth = (uintN) cg->stackDepth +
cg->maxStackDepth = depth;
nuses = js_GetStackUses(cs, op, pc);
cg->stackDepth -= nuses;
JS_ASSERT(cg->stackDepth >= 0);
JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
ndefs = cs->ndefs;
blockObj = cg->objectList.lastbox->object;
JS_ASSERT(STOBJ_GET_CLASS(blockObj) == &js_BlockClass);
JS_ASSERT(JSVAL_IS_VOID(blockObj->fslots[JSSLOT_BLOCK_DEPTH]));
OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
cg->stackDepth += ndefs;
cg->maxStackDepth = cg->stackDepth;
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
ptrdiff_t offset = EmitCheck(cx, cg, op, length);
jsbytecode *next = CG_NEXT(cg);
UpdateDepth(cx, cg, offset);
JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
jt = *jtp;
jt2 = jt->kids[otherDir];
*jtp = root = jt2->kids[dir];
*jtp = root = jt->kids[otherDir];
jt = cg->jtFreeList;
jt->offset = args->offset;
jt->balance = 0;
jt->kids[JT_LEFT] = jt->kids[JT_RIGHT] = NULL;
*jtp = jt;
? 1 - BalanceJumpTargets(jtp)
JS_ASSERT(-1 <= jt->balance && jt->balance <= 1);
JS_ASSERT(jt->balance == rh - lh);
ReportStatementTooLarge(cx, cg);
AddJumpTarget(&args, &cg->jumpTargets);
AVLCheck(cg->jumpTargets);
index = cg->numSpanDeps;
ReportStatementTooLarge(cx, cg);
(!(sdbase = cg->spanDeps) || index >= SPANDEPS_MIN)) {
size = sdbase ? SPANDEPS_SIZE(index) : SPANDEPS_SIZE_MIN / 2;
sdbase = (JSSpanDep *) JS_realloc(cx, sdbase, size + size);
cg->spanDeps = sdbase;
cg->numSpanDeps = index + 1;
sd->top = PTRDIFF(pc, CG_BASE(cg), jsbytecode);
sd->offset = sd->before = PTRDIFF(pc2, CG_BASE(cg), jsbytecode);
ReportStatementTooLarge(cx, cg);
if (!SetSpanDepTarget(cx, cg, sd, off))
if (!AddSpanDep(cx, cg, pc, pc2, off))
pc = AddSwitchSpanDeps(cx, cg, pc);
if (!AddSpanDep(cx, cg, pc, pc, off))
UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
UpdateJumpTargets(cg->jumpTargets, sd2->offset,
JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
ts->filename ? ts->filename : "stdin", cg->firstLine,
growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
sd2 = FindNearestSpanDep(cg, target,
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
jmp = js_Emit3(cx, cg, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
pc = CG_CODE(cg, jmp);
if (!AddSpanDep(cx, cg, pc, pc, off))
if (!BuildSpanDepTable(cx, cg))
return SetSpanDepTarget(cx, cg, GetSpanDep(cg, pc), off);
stmt->flags = 0;
stmt->blockid = tc->blockid();
stmt->label = NULL;
JS_ASSERT(!stmt->blockObj);
stmt->down = tc->topStmt;
if (STMT_LINKS_SCOPE(stmt)) {
tc->topScopeStmt = stmt;
stmt->downScope = NULL;
js_PushStatement(tc, stmt, STMT_BLOCK, top);
stmt->flags |= SIF_SCOPE;
stmt->downScope = tc->topScopeStmt;
tc->topScopeStmt = stmt;
depth = cg->stackDepth;
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
if (js_Emit1(cx, cg, JSOP_LEAVEWITH) < 0)
if (js_Emit1(cx, cg, JSOP_ENDITER) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
i = OBJ_BLOCK_COUNT(cx, stmt->blockObj);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
cg->stackDepth = depth;
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
valueAtom = js_AtomizeDouble(cx, dval);
ale = cg->constList.add(cg->compiler, atom);
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &objbox,
ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
OBJ_DROP_PROPERTY(cx, objbox, prop);
} while ((cg = (JSCodeGenerator *) cg->parent) != NULL);
if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
bigSuffix = EmitBigIndexPrefix(cx, cg, index);
return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
return js_Emit1(cx, cg, JSOP_LENGTH) >= 0;
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
return EmitIndexOp(cx, op, ALE_INDEX(ale), cg);
return EmitIndexOp(cx, op, cg->objectList.index(objbox), cg);
JS_ASSERT((jsuint) slot < cg->maxStackDepth);
slot += cg->fun->u.i.nvars;
js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
slot = -1;
if (!EmitObjectOp(cx, pn->pn_objbox, JSOP_ENTERBLOCK, cg))
JSObject *blockObj = pn->pn_objbox->object;
jsint depth = AdjustBlockSlot(cx, cg, OBJ_BLOCK_DEPTH(cx, blockObj));
limit = slot + OBJ_BLOCK_COUNT(cx, blockObj);
js_ReallocSlots(cx, blockObj, JSSLOT_FREE(&js_BlockClass), JS_TRUE);
JSContext *cx = cg->compiler->context;
uintN upvarLevel = fun->u.i.script->staticLevel;
JSLocalKind localKind = js_LookupLocal(cx, fun, atom, &index);
JS_ASSERT(cg->staticLevel > upvarLevel);
JSAtomListElement *ale = cg->upvarList.lookup(atom);
!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR)) {
ale = cg->upvarList.add(cg->compiler, atom);
JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->upvarMap.length;
JS_ASSERT(ALE_INDEX(ale) <= length);
if (ALE_INDEX(ale) == length) {
length = 2 * JS_MAX(2, length);
vector = (uint32 *) JS_realloc(cx, vector, length * sizeof *vector);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
vector[ALE_INDEX(ale)] = MAKE_UPVAR_COOKIE(skip, index);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = MAKE_UPVAR_COOKIE(cg->staticLevel, ALE_INDEX(ale));
pn->pn_dflags |= PND_BOUND;
JS_ASSERT(pn->pn_type == TOK_NAME);
JS_ASSERT(pn->pn_op != JSOP_ARGUMENTS && pn->pn_op != JSOP_CALLEE);
JS_ASSERT(pn->pn_cookie == FREE_UPVAR_COOKIE);
pn->pn_dflags |= (dn->pn_dflags & PND_CONST);
op = PN_OP(pn);
JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
cookie = dn->pn_cookie;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
pn->pn_op = JSOP_FALSE;
pn->pn_dflags |= PND_BOUND;
if (pn->isConst())
pn->pn_op = op = JSOP_NAME;
JS_ASSERT(cg->flags & TCF_COMPILE_N_GO);
? STOBJ_GET_PARENT(FUN_OBJECT(cg->fun))
return MakeUpvarForEval(pn, cg);
case JSOP_NAME:     op = JSOP_GETGVAR; break;
case JSOP_SETNAME:  op = JSOP_SETGVAR; break;
case JSOP_INCNAME:  op = JSOP_INCGVAR; break;
case JSOP_NAMEINC:  op = JSOP_GVARINC; break;
case JSOP_DECNAME:  op = JSOP_DECGVAR; break;
case JSOP_NAMEDEC:  op = JSOP_GVARDEC; break;
pn->pn_op = op;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
uintN level = UPVAR_FRAME_SKIP(cookie);
JS_ASSERT(cg->staticLevel >= level);
JS_ASSERT(cg->staticLevel >= level);
pn->pn_op = JSOP_GETUPVAR;
pn->pn_cookie = cookie;
pn->pn_dflags |= PND_BOUND;
return MakeUpvarForEval(pn, cg);
JS_ASSERT(cg->flags & TCF_IN_FUNCTION);
JS_ASSERT(cg->lexdeps.lookup(atom));
if (FUN_FLAT_CLOSURE(cg->fun)) {
op = JSOP_GETDSLOT;
op = JSOP_GETUPVAR;
ale = cg->upvarList.lookup(atom);
index = ALE_INDEX(ale);
if (!js_AddLocal(cx, cg->fun, atom, JSLOCAL_UPVAR))
ale = cg->upvarList.add(cg->compiler, atom);
index = ALE_INDEX(ale);
JS_ASSERT(index == cg->upvarList.count - 1);
uint32 *vector = cg->upvarMap.vector;
uint32 length = cg->lexdeps.count;
if (!vector || cg->upvarMap.length != length)
vector = (UpvarCookie *) js_realloc(vector, length * sizeof *vector);
JS_ReportOutOfMemory(cx);
cg->upvarMap.vector = vector;
cg->upvarMap.length = length;
pn->pn_op = op;
pn->pn_cookie = index;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
case JSOP_NAME:     op = JSOP_GETARG; break;
case JSOP_SETNAME:  op = JSOP_SETARG; break;
case JSOP_INCNAME:  op = JSOP_INCARG; break;
case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
case JSOP_DECNAME:  op = JSOP_DECARG; break;
case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
case JSOP_FORNAME:  op = JSOP_FORARG; break;
JS_ASSERT(!pn->isConst());
JS_ASSERT(op != JSOP_CALLEE);
JS_ASSERT((cg->fun->flags & JSFUN_LAMBDA) && atom == cg->fun->atom);
JS_ASSERT(op != JSOP_DELNAME);
op = JSOP_CALLEE;
pn->pn_dflags |= PND_CONST;
pn->pn_op = op;
pn->pn_dflags |= PND_BOUND;
case JSOP_NAME:     op = JSOP_GETLOCAL; break;
case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
JS_ASSERT(op != PN_OP(pn));
pn->pn_op = op;
pn->pn_cookie = UPVAR_FRAME_SLOT(cookie);
pn->pn_dflags |= PND_BOUND;
JSAtomListElement *ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!EmitIndexOp(cx, JSOP_QNAMEPART, ALE_INDEX(ale), cg))
JS_ASSERT(pn->pn_arity == PN_NAME);
pn2 = pn->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pndown))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
if (!EmitSpecialPropOp(cx, pndot, JSOP_GETELEM, cg))
} else if (!EmitAtomOp(cx, pndot, PN_OP(pndot), cg)) {
if (!js_EmitTree(cx, cg, pn2))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
JSParseNode *left, *right, *next, ltmp, rtmp;
JS_ASSERT(pn->pn_op == JSOP_GETELEM);
JS_ASSERT(pn->pn_count >= 3);
left = pn->pn_head;
right = pn->last();
next = left->pn_next;
JS_ASSERT(next != right);
if (!BindNameToSlot(cx, cg, left))
next = left->pn_next;
JS_ASSERT(next != right || pn->pn_count == 3);
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, next))
left = &ltmp;
JS_ASSERT(ATOM_IS_STRING(pn->pn_atom));
right->pn_op = js_IsIdentifier(ATOM_TO_STRING(pn->pn_atom))
JS_ASSERT(pn->pn_arity == PN_BINARY);
if (!BindNameToSlot(cx, cg, left))
if (!js_EmitTree(cx, cg, left))
if (!js_EmitTree(cx, cg, right))
return js_Emit1(cx, cg, JSOP_ZERO) >= 0;
return js_Emit1(cx, cg, JSOP_ONE) >= 0;
return js_Emit2(cx, cg, JSOP_INT8, (jsbytecode)(int8)ival) >= 0;
off = js_EmitN(cx, cg, JSOP_UINT24, 3);
pc = CG_CODE(cg, off);
off = js_EmitN(cx, cg, JSOP_INT32, 4);
pc = CG_CODE(cg, off);
atom = js_AtomizeDouble(cx, dval);
ale = cg->atomList.add(cg->compiler, atom);
return EmitIndexOp(cx, JSOP_DOUBLE, ALE_INDEX(ale), cg);
JSStmtInfo *stmtInfo)
count = OBJ_BLOCK_COUNT(cx, pn2->pn_objbox->object);
js_PushBlockScope(cg, stmtInfo, pn2->pn_objbox->object, -1);
stmtInfo->type = STMT_SWITCH;
if (!EmitEnterBlock(cx, pn2, cg))
if (!js_EmitTree(cx, cg, pn->pn_left))
js_PushStatement(cg, stmtInfo, STMT_SWITCH, top);
atom = js_AtomizeDouble(cx, d);
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
atom = js_AtomizeDouble(cx, d);
JS_malloc(cx,
ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
JS_free(cx, intmap);
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
if (pn4 && !js_EmitTree(cx, cg, pn4))
if (!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
caseNoteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
off = EmitJump(cx, cg, JSOP_CASE, 0);
noteCount = CG_NOTE_COUNT(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1,
noteCountDelta = CG_NOTE_COUNT(cg) - noteCount;
!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
defaultOffset = EmitJump(cx, cg, JSOP_DEFAULT, 0);
pc = CG_CODE(cg, top + JUMP_OFFSET_LEN);
table = (JSParseNode **) JS_malloc(cx, tableSize);
if (!AddSwitchSpanDeps(cx, cg, CG_CODE(cg, top)))
savepc = CG_NEXT(cg);
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
ok = js_EmitTree(cx, cg, pn4);
off = CG_OFFSET(cg) - top;
ok = js_SetJumpOffset(cx, cg, CG_CODE(cg, defaultOffset),
ok = js_SetJumpOffset(cx, cg, pc, off);
off = CG_OFFSET(cg) - top;
ok = js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, off);
ale = cg->atomList.add(cg->compiler, pn->pn_atom);
if (!UpdateLineNumberNotes(cx, cg, pn->pn_pos.begin.lineno))
CG_SWITCH_TO_MAIN(cg);
if (!emitter(cx, cg, prologOp, pn2))
if (!emitter(cx, cg, prologOp, pn3))
pn = pn->pn_kid;
if (!EmitDestructuringOpsHelper(cx, cg, pn))
if (!BindNameToSlot(cx, cg, pn))
if (pn->isConst() && !pn->isInitialized())
return js_Emit1(cx, cg, JSOP_POP) >= 0;
if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, cg))
if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, cg))
top = CG_OFFSET(cg);
if (!js_EmitTree(cx, cg, pn))
if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
intN stackDepth = cg->stackDepth;
JS_ASSERT(stackDepth != 0);
if (js_Emit1(cx, cg, JSOP_DUP) < 0)
if (!EmitNumberOp(cx, index, cg))
JS_ASSERT(pn2->pn_type == TOK_COLON);
if (js_NewSrcNote(cx, cg, SRC_INITPROP) < 0)
if (!EmitNumberOp(cx, pn3->pn_dval, cg))
pn3 = pn2->pn_right;
if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
JS_ASSERT(cg->stackDepth == stackDepth + 1);
JS_ASSERT(pn2 == pn3);
for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
pn3 = pn2;
if (!EmitDestructuringLHS(cx, cg, pn3))
JS_ASSERT(cg->stackDepth == stackDepth);
JS_ASSERT(cg->stackDepth == stackDepth + 1);
if (!EmitDestructuringLHS(cx, cg, pn3))
return EmitDestructuringOpsHelper(cx, cg, pn);
depth = limit = (uintN) cg->stackDepth;
if (!js_EmitTree(cx, cg, pn))
i = depth;
JS_ASSERT(i < limit);
jsint slot = AdjustBlockSlot(cx, cg, i);
if (js_Emit1(cx, cg, JSOP_POP) < 0)
if (!EmitDestructuringLHS(cx, cg, pn))
JS_ASSERT(pn->pn_type == TOK_ASSIGN);
JSParseNode *pn, JSOp *pop)
lhs = pn->pn_left;
if (!EmitGroupAssignment(cx, cg, prologOp, lhs, rhs))
JSParseNode *lhs, JSParseNode *rhs)
for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
if (!EmitDestructuringLHS(cx, cg, pn))
off = noteIndex = -1;
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn2))
JS_ASSERT(pn2->pn_left->pn_type == TOK_NAME);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
if (!MaybeEmitGroupAssignment(cx, cg,
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn3))
if (!js_EmitTree(cx, cg, pn2->pn_right))
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!MaybeEmitVarDecl(cx, cg, PN_OP(pn), pn2, &atomIndex))
!js_DefineCompileTimeConstant(cx, cg, pn2->pn_atom, pn3)) {
if (!js_EmitTree(cx, cg, pn3))
js_NewSrcNote2(cx, cg, SRC_DECL,
if (js_Emit1(cx, cg, op) < 0)
tmp = CG_OFFSET(cg);
if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
index = CG_NOTE_COUNT(cg);
if (((uintN)index & CG_NOTE_MASK(cg)) == 0) {
if (!CG_NOTES(cg)) {
js_ReportOutOfScriptQuota(cx);
return -1;
return index;
index = AllocSrcNote(cx, cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
return -1;
sn = &CG_NOTES(cg)[index];
offset = CG_OFFSET(cg);
delta = offset - CG_LAST_NOTE_OFFSET(cg);
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
index = AllocSrcNote(cx, cg);
return -1;
sn = &CG_NOTES(cg)[index];
if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
if (js_NewSrcNote(cx, cg, SRC_NULL) < 0)
return -1;
return index;
index = js_NewSrcNote(cx, cg, type);
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
return -1;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
return index;
noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
pn2, &op)) {
JSParseNode *pn, JSOp *pop)
pn2, &op)) {
pn3 = pn2->maybeExpr();
if (!BindNameToSlot(cx, cg, pn2))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
if (!js_SetSrcNoteOffset(cx, cg, index, 1, offset2))
js_ReportOutOfScriptQuota(cx);
sn = &CG_NOTES(cg)[index];
JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
for (sn++; which; sn++, which--) {
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (!GrowSrcNotes(cx, cg))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
if (!EmitDestructuringLHS(cx, cg, pn3))
if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
sd2 = FindNearestSpanDep(cg, target,
sn += 2;
index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
sn = CG_NOTES(cg) + index;
diff = CG_NOTE_COUNT(cg) - (index + 3);
JS_ASSERT(diff >= 0);
memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
0

