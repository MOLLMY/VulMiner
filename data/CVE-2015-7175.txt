639 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp cfunc 1038
rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText));
uint32_t aLength)
return AddText(aData, aLength);
mTextLength = 0;
rv = HandleStartElement(parsererror.get(), noAtts, 0, 0);
rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText));
rv = HandleCharacterData(aSourceText, NS_strlen(aSourceText));
int32_t aLength)
mText = (char16_t *) malloc(sizeof(char16_t) * 4096);
int32_t offset = 0;
mTextLength += amount;
int32_t amount = mTextSize - mTextLength;
amount = aLength;
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
aLength -= amount;
mTextSize += aLength;
offset += amount;
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
XULContentSinkImpl::ReportError(const char16_t* aErrorText,
NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText));
uint32_t aLength)
return AddText(aData, aLength);
int32_t aLength)
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
XULContentSinkImpl::HandleCharacterData(const char16_t *aData,
return AddText(aData, aLength);
XULContentSinkImpl::AddText(const char16_t* aText,
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
XULContentSinkImpl::HandleCDataSection(const char16_t *aData, uint32_t aLength)
return AddText(aData, aLength);
1

640 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp cppfunc 1038
XULContentSinkImpl::HandleCDataSection(const char16_t *aData, uint32_t aLength)
return AddText(aData, aLength);
const char16_t* aSourceText,
nsIScriptError *aError,
NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
mTextLength = 0;
rv = HandleStartElement(parsererror.get(), noAtts, 0, 0);
rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText));
uint32_t aLength)
return AddText(aData, aLength);
rv = HandleCharacterData(aSourceText, NS_strlen(aSourceText));
uint32_t aLength)
return AddText(aData, aLength);
int32_t aLength)
mText = (char16_t *) malloc(sizeof(char16_t) * 4096);
mTextSize = 4096;
int32_t offset = 0;
int32_t amount = mTextSize - mTextLength;
amount = aLength;
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
mTextLength += amount;
int32_t amount = mTextSize - mTextLength;
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
aLength -= amount;
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
XULContentSinkImpl::ReportError(const char16_t* aErrorText,
NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText));
uint32_t aLength)
return AddText(aData, aLength);
int32_t aLength)
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
XULContentSinkImpl::HandleCharacterData(const char16_t *aData,
return AddText(aData, aLength);
XULContentSinkImpl::AddText(const char16_t* aText,
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
1

13098 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13136 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13174 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
component_data = sizeof(char16_t);
memcpy(&mText[mTextLength],aText + offset, component_data * amount);
0

13211 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
component_data = sizeof(char16_t);
memcpy(&mText[mTextLength],aText + offset, component_data * amount);
1

13230 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = func(&aLength);
int32_t func(int32_t *aLength)
return *aLength;
amount = func(&aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13249 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = func(&aLength);
int32_t func(int32_t *aLength)
return *aLength;
amount = func(&aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13268 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
int32_t dataArray[5];
dataArray[2] = aLength;
size += goodSource(dataArray);
int32_t goodSource(int32_t dataArray[])
int32_t aLength = dataArray[2];
return aLength;
size += goodSource(dataArray);
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13286 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
int32_t dataArray[5];
dataArray[2] = aLength;
mTextSize += badSource(dataArray);
int32_t badSource(int32_t dataArray[])
int32_t aLength = dataArray[2];
return aLength;
mTextSize += badSource(dataArray);
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13311 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
int32_t (*funcPtr)(int32_t ) = goodSource;
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = funcPtr(aLength);
int32_t goodSource(int32_t aLength)
return aLength;
amount = funcPtr(aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13337 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
int32_t (*funcPtr)(int32_t ) = badSource;
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = funcPtr(aLength);
int32_t badSource(int32_t aLength)
return aLength;
amount = funcPtr(aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13363 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = func(aLength);
int32_t func(int32_t aLength)
return aLength;
amount = func(aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13389 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = func(aLength);
int32_t func(int32_t aLength)
return aLength;
amount = func(aLength);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13426 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
int32_t *dataType = &offset;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
uint32_t offset = *dataType;
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13464 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
int32_t *dataType = &offset;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
uint32_t offset = *dataType;
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13484 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
structType myStruct;
myStruct.structFirst = aLength;
amount = func(myStruct);
int32_t func(structType myStruct)
int32_t aLength = myStruct.structFirst;
return aLength;
amount = func(myStruct);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13502 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
structType myStruct;
myStruct.structFirst = aLength;
amount = func(myStruct);
int32_t func(structType myStruct)
int32_t aLength = myStruct.structFirst;
return aLength;
amount = func(myStruct);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13520 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
unionType myUnion;
myUnion.unionFirst = aLength;
amount = func(myUnion);
int32_t func(unionType myUnion)
int32_t aLength = myUnion.unionSecond;
return aLength;
amount = func(myUnion);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

13538 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
unionType myUnion;
myUnion.unionFirst = aLength;
amount = func(myUnion);
int32_t func(unionType myUnion)
int32_t aLength = myUnion.unionSecond;
return aLength;
amount = func(myUnion);
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

13976 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv;   }
} else {
CheckedInt32 size = mTextSize;
size += aLength;
if (!size.isValid()) {
return NS_ERROR_OUT_OF_MEMORY; }
mTextSize = size.value();
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
0

14014 CVE-2015-7175/Firefox_40.0b9_CVE_2015_7175_dom_xul_nsXULContentSink.cpp Buffer_Overflow_boundedcpy 1044
nsresult XULContentSinkImpl::AddText(const char16_t* aText, int32_t aLength)
int32_t offset = 0;
while (0 != aLength) {
int32_t amount = mTextSize - mTextLength;
if (amount > aLength) {
amount = aLength;}
if (0 == amount) {
if (mConstrainSize) {
nsresult rv = FlushText();
if (NS_OK != rv) {
return rv; }
} else {
mTextSize += aLength;
mText = (char16_t *) realloc(mText, sizeof(char16_t) * mTextSize);
if (nullptr == mText) {
return NS_ERROR_OUT_OF_MEMORY;      }}}
memcpy(&mText[mTextLength],aText + offset, sizeof(char16_t) * amount);
1

