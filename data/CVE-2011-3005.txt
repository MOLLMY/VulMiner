246 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp cfunc 1254
int backsteps = 0;
const int maxBackStep = 10;
NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
backsteps = NS_MIN(backsteps + 1, maxBackStep);
backsteps = 0;
static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
0

247 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp cppfunc 1254
int backsteps = 0;
const int maxBackStep = 10;
NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
backsteps = NS_MIN(backsteps + 1, maxBackStep);
backsteps = 0;
static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
0

649 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp cfunc 278
ogg_page page;
PRInt64 pageOffset = ReadOggPage(&page);
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page)) {
codecState = nsOggCodecState::Create(&page);
mCodecStates.Put(serial, codecState);
bitstreams.AppendElement(codecState);
codecState->GetType() == nsOggCodecState::TYPE_VORBIS &&
mVorbisState = static_cast<nsVorbisState*>(codecState);
codecState->GetType() == nsOggCodecState::TYPE_THEORA &&
mTheoraState = static_cast<nsTheoraState*>(codecState);
codecState->GetType() == nsOggCodecState::TYPE_SKELETON &&
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page))) {
codecState = nsOggCodecState::Create(&page);
codecState->GetType() == nsOggCodecState::TYPE_THEORA &&
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (mTheoraState && ReadHeaders(mTheoraState)) {
mInfo.mPicture = nsIntRect(mTheoraState->mInfo.pic_x,
mTheoraState->mInfo.pic_y,
mTheoraState->mInfo.pic_width,
mTheoraState->mInfo.pic_height);
mInfo.mFrame = nsIntSize(mTheoraState->mInfo.frame_width,
mTheoraState->mInfo.frame_height);
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
PRBool nsOggReader::ReadHeaders(nsOggCodecState* aState)
while (!aState->DoneReadingHeaders()) {
if (mTheoraState && ReadHeaders(mTheoraState)) {
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
PRBool nsOggReader::ReadHeaders(nsOggCodecState* aState)
if (mTheoraState && ReadHeaders(mTheoraState)) {
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
PRInt64 nsOggReader::ReadOggPage(ogg_page* aPage)
while((ret = ogg_sync_pageseek(&mOggState, aPage)) <= 0) {
PRInt64 pageOffset = ReadOggPage(&page);
codecState = nsOggCodecState::Create(&page);
codecState->GetType() == nsOggCodecState::TYPE_THEORA &&
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (mTheoraState && ReadHeaders(mTheoraState)) {
1

13042 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = nsOggCodecState::Create(&page);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13043 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = nsOggCodecState::Create(&page);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13692 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = func(codecState);
static nsOggCodecState * func(const nsOggCodecState * codecState)
codecState = nsOggCodecState::Create(&page);
return codecState;
codecState = func(codecState);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13693 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = func(codecState);
static nsOggCodecState * func(const nsOggCodecState * codecState)
codecState = nsOggCodecState::Create(&page);
return codecState;
codecState = func(codecState);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13694 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = func(&codecState);
static nsOggCodecState * func(nsOggCodecState * * ptr)
nsOggCodecState * codecState = *ptr;
codecState = nsOggCodecState::Create(&page);
return codecState;
codecState = func(&codecState);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13695 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = func(&codecState);
static nsOggCodecState * func(nsOggCodecState * * ptr)
nsOggCodecState * codecState = *ptr;
codecState = nsOggCodecState::Create(&page);
return codecState;
codecState = func(&codecState);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13696 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
void (*funcPtr) (nsOggCodecState *) = badSource;
funcPtr(codecState)
void badSource(nsOggCodecState * codecState)
codecState = nsOggCodecState::Create(&page);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13697 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
void (*funcPtr) (nsOggCodecState *) = badSource;
funcPtr(codecState)
void badSource(nsOggCodecState * codecState)
codecState = nsOggCodecState::Create(&page);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13698 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = nsOggCodecState::Create(&page);
nsOggCodecState * dataCopy = codecState;
nsOggCodecState * codecState = dataCopy;
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13699 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = nsOggCodecState::Create(&page);
nsOggCodecState * dataCopy = codecState;
nsOggCodecState * codecState = dataCopy;
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13700 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = nsOggCodecState::Create(&page);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
instead = codecState && codecState->GetType();
if (instead == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (instead == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (instead == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13701 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = nsOggCodecState::Create(&page);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
instead = codecState && codecState->GetType();
if (instead == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (instead == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (instead == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13702 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
codecState = nsOggCodecState::Create(&page);
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13703 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
codecState = nsOggCodecState::Create(&page);
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13704 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
nsOggCodecState * dataArray[5];
dataArray[2] = codecState;
codecState = badSource(dataArray);
void badSource(nsOggCodecState * dataArray[])
nsOggCodecState * codecState = dataArray[2];
codecState = nsOggCodecState::Create(&page);
return codecState;
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13705 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
nsOggCodecState * dataArray[5];
dataArray[2] = codecState;
codecState = badSource(dataArray);
void badSource(nsOggCodecState * dataArray[])
nsOggCodecState * codecState = dataArray[2];
codecState = nsOggCodecState::Create(&page);
return codecState;
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13706 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
unionType myUnion;
codecState = nsOggCodecState::Create(&page);
myUnion.unionFirst = codecState;
nsOggCodecState * codecState = myUnion.unionSecond;
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13707 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
unionType myUnion;
codecState = nsOggCodecState::Create(&page);
myUnion.unionFirst = codecState;
nsOggCodecState * codecState = myUnion.unionSecond;
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

13708 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (ogg_page_bos(&page))
NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
structType myStruct;
myStruct.structFirst = codecState;
codecState = badSource(myStruct);
void badSource(structType myStruct)
nsOggCodecState * codecState = myStruct.structFirst;
codecState = nsOggCodecState::Create(&page);
return codecState;
#ifdef DEBUG
PRBool r =
#endif
mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
else
readAllBOS = PR_TRUE;
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
1

13709 CVE-2011-3005/Firefox_6.0_CVE_2011_3005_content_media_ogg_nsOggReader.cpp Buffer_Overflow_boundedcpy 289
int serial = ogg_page_serialno(&page);
nsOggCodecState* codecState = 0;
if (!ogg_page_bos(&page))
readAllBOS = PR_TRUE;
else if (!mCodecStates.Get(serial, nsnull))
structType myStruct;
myStruct.structFirst = codecState;
codecState = badSource(myStruct);
void badSource(structType myStruct)
nsOggCodecState * codecState = myStruct.structFirst;
codecState = nsOggCodecState::Create(&page);
return codecState;
DebugOnly<PRBool> r = mCodecStates.Put(serial, codecState);
NS_ASSERTION(r, "Failed to insert into mCodecStates");
bitstreams.AppendElement(codecState);
mKnownStreams.AppendElement(serial);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_VORBIS && !mVorbisState)
mVorbisState = static_cast<nsVorbisState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_THEORA && !mTheoraState)
mTheoraState = static_cast<nsTheoraState*>(codecState);
if (codecState && codecState->GetType() == nsOggCodecState::TYPE_SKELETON && !mSkeletonState)
mSkeletonState = static_cast<nsSkeletonState*>(codecState);
mCodecStates.Get(serial, &codecState);
NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
if (NS_FAILED(codecState->PageIn(&page)))
return NS_ERROR_FAILURE;
memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
0

