5 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 196
DumpStyleGeneaology(nsIFrame* aFrame, const char* gap)
nsFrame::ListTag(stdout, aFrame);
nsStyleContext* sc = aFrame->GetStyleContext();
printf("%p ", sc);
psc = sc->GetParent();
sc = psc;
printf("%p ", sc);
0

13 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 373
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
0

14 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5812
nsIFrame*           aFloat,
NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
aFloat, this,
nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
if (!aFloat->GetPrevInFlow()) {
rv = brc.ReflowBlock(aAdjustedAvailableSpace, true, margin,
if (aFloat->GetType() == nsGkAtoms::letterFrame) {
const nsHTMLReflowMetrics& metrics = brc.GetMetrics();
aFloat->SetSize(nsSize(metrics.width, metrics.height));
if (aFloat->HasView()) {
nsContainerFrame::SyncFrameViewAfterReflow(aState.mPresContext, aFloat,
aFloat->DidReflow(aState.mPresContext, &floatRS,
aFloat, metrics.width, metrics.height);
0

25 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 378
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
0

28 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5396
nsIFrame* aOldFrame)
nsFrame::ListTag(stdout, aOldFrame);
bool hasFloats = BlockHasAnyFloats(aOldFrame);
rv = DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
return DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
if (line->Contains(aDeletedFrame)) {
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
line->mFirstChild = aDeletedFrame->GetNextSibling();
overflowLines->mFrames.RemoveFrame(aDeletedFrame);
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
deletedNextContinuation->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
deletedNextContinuation = nullptr;
aDeletedFrame = deletedNextContinuation;
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
nsIFrame*      aNextInFlow,
NS_PRECONDITION(aNextInFlow->GetPrevInFlow(), "bad next-in-flow");
if (aNextInFlow->GetStateBits() &
nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
DoRemoveFrame(aNextInFlow,
static nsresult RemoveBlockChild(nsIFrame* aFrame,
nsBlockFrame* nextBlock = nsLayoutUtils::GetAsBlock(aFrame->GetParent());
return nextBlock->DoRemoveFrame(aFrame,
nsBlockFrame::DoRemoveFrame(nsIFrame* aDeletedFrame, uint32_t aFlags)
if (aDeletedFrame->GetStateBits() &
NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
mFrames.RemoveFrame(aDeletedFrame);
line->NoteFrameRemoved(aDeletedFrame);
aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
nsFrame::ListTag(stdout, aDeletedFrame);
aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
0

55 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 145
const BlockDebugFlags* bdf = gFlags;
const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
*(bdf->on) = true;
for (; bdf < end; bdf++) {
if (PL_strcasecmp(bdf->name, flags) == 0) {
printf("nsBlockFrame: setting %s debug flag on\n", bdf->name);
0

84 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 408
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
0

87 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 401
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
0

90 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 402
nsAutoString atomString;
pseudoTag->ToString(atomString);
NS_LossyConvertUTF16toASCII(atomString).get());
0

91 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 405
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
0

124 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 367
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
0

142 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 815
nsBlockFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
InlinePrefWidthData data;
curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
line == curFrame->begin_lines()) {
if (!curFrame->GetPrevContinuation() &&
const nsStyleCoord &indent = GetStyleText()->mTextIndent;
if (indent.ConvertsToLength())
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
data.lineContainer = curFrame;
for (int32_t i = 0, i_end = line->GetChildCount(); i != i_end;
data.line = &line;
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
return nsBidiPresUtils::Resolve(this);
for (nsBlockFrame* curFrame = this; curFrame;
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
line->IsBlock() ? "block" : "inline",
line->IsEmpty() ? ", empty" : "");
if (line->IsBlock()) {
line->mFirstChild, nsLayoutUtils::PREF_WIDTH);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
data.line = &line;
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
kid->AddInlinePrefWidth(aRenderingContext, &data);
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
data.prevLines, data.currentLine);
0

164 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1819
nsBlockFrame::BlockNeedsFloatManager(nsIFrame* aBlock)
NS_PRECONDITION(aBlock, "Must have a frame");
NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlock), "aBlock must be a block");
nsIFrame* parent = aBlock->GetParent();
return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
(parent && !parent->IsFloatContainingBlock());
return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::DrainPushedFloats(nsBlockReflowState& aState)
DrainPushedFloats(state);
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
*aBottomMarginRoot = GetNextInFlow() == nullptr;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aTopMarginRoot = true;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aBottomMarginRoot = true;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
rv = ReflowDirtyLines(state);
if (0 != aState.ClearFloats(0, NS_STYLE_CLEAR_LEFT_AND_RIGHT)) {
nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
rv = ReflowPushedFloats(state, fcBounds, fcStatus);
rv = ReflowDirtyLines(state);
nsBlockFrame::ReflowDirtyLines(nsBlockReflowState& aState)
printf(" computedWidth=%d\n", aState.mReflowState.ComputedWidth());
nsBlockFrame::GetEffectiveComputedHeight(const nsHTMLReflowState& aReflowState) const
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nscoord height = aReflowState.ComputedHeight();
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::Reflow(nsPresContext*           aPresContext,
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
*aTopMarginRoot = false;
*aBottomMarginRoot = false;
*aTopMarginRoot = GetPrevInFlow() == nullptr;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
nsBlockFrame::IsMarginRoot(bool* aTopMarginRoot, bool* aBottomMarginRoot)
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
topMarginRoot, bottomMarginRoot, needFloatManager);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
DrainPushedFloats(state);
0

172 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 120
const BlockDebugFlags* bdf = gFlags;
for (; bdf < end; bdf++) {
printf("  %s\n", bdf->name);
0

224 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 354
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
0

238 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1246
char buf[400];
PR_snprintf(buf, sizeof(buf),
printf("%s\n", buf);
0

244 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 359
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
void* IBsibling = Properties().Get(IBSplitSpecialSibling());
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
0

249 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 351
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
0

265 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp API 586
aOldParent, aNewParent);
nsIFrame* aNewParent)
ReparentFrame(e.get(), aOldParent, aNewParent);
ReparentFrame(nsIFrame* aFrame, nsIFrame* aOldParent, nsIFrame* aNewParent)
aFrame->SetParent(aNewParent);
0

266 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1795
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nsRect ovis(aLine->GetVisualOverflowArea());
ovis.x, ovis.y, ovis.width, ovis.height,
0

267 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1797
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nscoord aDeltaY, int32_t aDeltaIndent) {
nsRect ovis(aLine->GetVisualOverflowArea());
nsRect oscr(aLine->GetScrollableOverflowArea());
static_cast<void*>(aLine), aState.mY,
aLine->IsDirty() ? "yes" : "no",
aDeltaY, aState.mPrevBottomMargin.get(), aLine->GetChildCount());
0

268 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1796
static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
nsRect ovis(aLine->GetVisualOverflowArea());
nsRect oscr(aLine->GetScrollableOverflowArea());
oscr.x, oscr.y, oscr.width, oscr.height,
0

269 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6035
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
static_cast<void*>(aLine),
0

274 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6039
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
lineArea.width, lineArea.height);
0

275 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6038
const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
DebugOutputDrawLine(aDepth, aLine.get(), intersect);
static void DebugOutputDrawLine(int32_t aDepth, nsLineBox* aLine, bool aDrawn) {
nsRect lineArea = aLine->GetVisualOverflowArea();
lineArea.x, lineArea.y,
0

292 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 735
nsBlockFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
InlineMinWidthData data;
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
kid->AddInlineMinWidth(aRenderingContext, &data);
data.ForceBreak(aRenderingContext);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
kid->AddInlineMinWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
return nsBidiPresUtils::Resolve(this);
for (nsBlockFrame* curFrame = this; curFrame;
curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
line->IsBlock() ? "block" : "inline",
line->IsEmpty() ? ", empty" : "");
if (line->IsBlock()) {
line->mFirstChild, nsLayoutUtils::MIN_WIDTH);
data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
data.line = &line;
data.ForceBreak(aRenderingContext);
data.ForceBreak(aRenderingContext);
line == curFrame->begin_lines()) {
if (!curFrame->GetPrevContinuation() &&
const nsStyleCoord &indent = GetStyleText()->mTextIndent;
if (indent.ConvertsToLength())
kid->AddInlineMinWidth(aRenderingContext, &data);
data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
for (int32_t i = 0, i_end = line->GetChildCount(); i != i_end;
data.line = &line;
data.lineContainer = curFrame;
data.prevLines, data.currentLine);
kid->AddInlineMinWidth(aRenderingContext, &data);
data.prevLines, data.currentLine);
0

293 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 4122
aAvailableSpaceHeight = NS_MAX(aAvailableSpaceHeight, aLine->mBounds.height);
aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
if (CRAZY_HEIGHT(aLine->mBounds.y)) {
lastHeight = aLine->mBounds.y;
if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
aLine->mBounds.y, aLine->mBounds.height);
0

304 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 414
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
0

306 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 411
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
0

314 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 396
int32_t numInlineLines = 0;
int32_t numBlockLines = 0;
numBlockLines++;
numInlineLines++;
static_cast<void*>(mStyleContext), numInlineLines, numBlockLines);
0

331 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1660
for (line_iterator line = begin_lines(), line_end = end_lines();
line->IsImpactedByFloat() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->mBounds.XMost());
0

333 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cppfunc 6153
return nullptr;
FrameProperties props = Properties();
(props.Get(LineCursorProperty()));
nsLineBox* property = static_cast<nsLineBox*>
line_iterator cursor = mLines.begin(property);
nsRect cursorArea = cursor->GetVisualOverflowArea();
cursor = cursor.prev();
cursorArea = cursor->GetVisualOverflowArea();
cursor = cursor.next();
cursorArea = cursor->GetVisualOverflowArea();
if (cursor.get() != property) {
props.Set(LineCursorProperty(), cursor.get());
return cursor.get();
nullptr : GetFirstLineContaining(aDirtyRect.y);
nsLineBox* cursor = aBuilder->ShouldDescendIntoFrame(this) ?
for (line_iterator line = mLines.begin(cursor);
0

337 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1598
const nsStyleText* styleText = GetStyleText();
IsAlignedLeft(styleText->mTextAlign,
styleText->mTextAlign);
0

339 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cppfunc 4118
aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
if (CRAZY_HEIGHT(aLine->mBounds.y)) {
lastHeight = aLine->mBounds.y;
if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
0

356 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 458
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
fputs("<\n", out);
line->List(out, aIndent, aFlags);
IndentBy(out, aIndent);
fputs("Overflow-lines<\n", out);
line->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
IndentBy(out, aIndent);
fputs(">\n", out);
0

358 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 451
ChildListIterator lists(this);
for (; !lists.IsDone(); lists.Next()) {
if (skip.Contains(lists.CurrentID())) {
IndentBy(out, aIndent);
kid->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
nsFrameList::Enumerator childFrames(lists.CurrentList());
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
0

373 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1659
if (line->IsBlock() ||
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
line->MarkDirty();
if (!line->IsBlock()) {
line.get(), line->IsImpactedByFloat() ? "" : "not ");
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
0

376 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1652
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
if (line->IsBlock() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
0

377 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1653
for (line_iterator line = begin_lines(), line_end = end_lines();
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
if (line->IsBlock() ||
line->IsImpactedByFloat() ||
if (!line->IsBlock()) {
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
0

397 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6889
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
0

398 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6230
char buf[400];
PR_snprintf(buf, sizeof(buf),
printf("%s\n", buf);
0

416 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 463
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
fputs("<\n", out);
line->List(out, aIndent, aFlags);
IndentBy(out, aIndent);
fputs("Overflow-lines<\n", out);
line->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fprintf(out, "%s<\n", mozilla::layout::ChildListName(lists.CurrentID()));
kid->List(out, aIndent + 1, aFlags);
IndentBy(out, aIndent);
fputs(">\n", out);
IndentBy(out, aIndent);
fputs(">\n", out);
0

423 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 238
int index = 0;
if (!aChildIsBlock) index |= 1;
printf("record(%d): %02x %02x\n", index, record[0], record[1]);
0

443 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 343
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
0

445 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 346
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
0

469 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 5415
line = line_end;
TryAllLines(&line, &line_start, &line_end, &searchingOverflowList,
nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,
TryAllLines(&line, &line_start, &line_end, &searchingOverflowList,
searchingOverflowList?"overflow":"normal", line.get());
NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
bool isLastFrameOnLine = 1 == line->GetChildCount();
if (line != line_end && !line->IsBlock()) {
line->NoteFrameRemoved(aDeletedFrame);
searchingOverflowList?"overflow":"normal", line.get());
if (0 == line->GetChildCount()) {
searchingOverflowList?"overflow":"normal", line.get());
0

488 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 933
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
0

497 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 379
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
overflowArea.width, overflowArea.height);
0

505 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 382
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
overflowArea = f->GetScrollableOverflowRect();
overflowArea.width, overflowArea.height);
0

506 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 381
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
if (f->HasOverflowAreas()) {
nsRect overflowArea = f->GetVisualOverflowRect();
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
overflowArea = f->GetScrollableOverflowRect();
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
0

510 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 6886
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
if (line->IsDirty()) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
fc = fc->Next();
lineFloats.AppendElement(fc->mFloat);
if (i < lineFloats.Length() && lineFloats.ElementAt(i) != f) {
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
0

532 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 439
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
fprintf(out, " [content=%p]", static_cast<void*>(mContent));
fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
fprintf(out, " [state=%016llx]", (unsigned long long)mState);
fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
fprintf(out, " sc=%p(i=%d,b=%d)",
fprintf(out, " pst=%s",
fprintf(out, " transformed");
fprintf(out, " perspective");
fprintf(out, " preserves-3d-children");
fprintf(out, " preserves-3d");
fputs("<\n", out);
line->List(out, aIndent, aFlags);
IndentBy(out, aIndent);
fputs("Overflow-lines<\n", out);
IndentBy(out, aIndent);
fputs(">\n", out);
0

565 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 4246
nsRect &o = lineOverflowAreas.Overflow(otype);
o = aLine->GetOverflowArea(otype);
otype,
0

566 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 4247
if (aState.GetFlag(BRS_APPLYTOPMARGIN)) {
if (!aState.IsAdjacentWithTop()) {
if (aState.GetFlag(BRS_HAVELINEADJACENTTOTOP)) {
aState.SetFlag(BRS_HAVELINEADJACENTTOTOP, true);
if (ShouldApplyTopMargin(aState, aLine)) {
nsFlowAreaRect floatAvailableSpace = aState.GetFloatAvailableSpace();
lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
rv = DoReflowInlineFrames(aState, lineLayout, aLine,
!aFrame->IsFrameOfType(nsIFrame::eReplaced) &&
return aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
(line->GetBreakTypeBefore() != NS_STYLE_CLEAR_NONE ||
bool previousMarginWasDirty = line->IsPreviousMarginDirty();
(line->IsBlock() || line->HasFloats() || line->HadFloatPushed())) {
if (!line->IsDirty()) {
if (needToRecoverState && line->IsDirty()) {
if (line->IsDirty() && (line->HasFloats() || !willReflowAgain)) {
NS_ASSERTION(!willReflowAgain || !line->IsBlock(),
rv = ReflowLine(aState, line, &keepGoing);
line_iterator aLine,
rv = ReflowInlineFrames(aState, aLine, aKeepReflowGoing);
line_iterator aLine,
aLine->SetLineIsImpactedByFloat(false);
if (ShouldApplyTopMargin(aState, aLine)) {
nsLineBox* aLine)
if (ShouldApplyTopMargin(aState, aLine)) {
rv = DoReflowInlineFrames(aState, lineLayout, aLine,
line_iterator aLine,
aLine->EnableResizeReflowOptimization();
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
aLine = mLines.erase(aLine);
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
line_iterator aLine,
rv = DoReflowInlineFrames(aState, lineLayout, aLine,
line_iterator aLine,
aLine->EnableResizeReflowOptimization();
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
if (!PlaceLine(aState, aLineLayout, aLine, aFloatStateBeforeLine,
line_iterator       aLine,
IsLastLine(aState, aLine)));
aLine->SetOverflowAreas(overflowAreas);
if (!aLine->CachedIsEmpty()) {
aLine->AppendFloats(aState.mCurrentLineFloats);
if (aLine->HasFloats()) {
o = aLine->GetOverflowArea(otype);
o.x, o.y, o.width, o.height,
nsBlockFrame::DoReflowInlineFrames(nsBlockReflowState& aState,
rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
nsBlockFrame::ReflowInlineFrame(nsBlockReflowState& aState,
rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
(NS_STYLE_CLEAR_NONE != aState.mFloatBreakType), "bad break type");
NS_ASSERTION((NS_STYLE_CLEAR_NONE != breakType) ||
NS_ASSERTION(NS_STYLE_CLEAR_PAGE != breakType, "no page breaks yet");
aLine->SetBreakTypeAfter(breakType);
rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
aLine = mLines.erase(aLine);
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
line_iterator aLine,
rv = DoReflowInlineFrames(aState, lineLayout, aLine,
line_iterator aLine,
aLine->EnableResizeReflowOptimization();
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
if (!PlaceLine(aState, aLineLayout, aLine, aFloatStateBeforeLine,
line_iterator       aLine,
IsLastLine(aState, aLine)));
aLine->SetOverflowAreas(overflowAreas);
if (!aLine->CachedIsEmpty()) {
aLine->AppendFloats(aState.mCurrentLineFloats);
if (aLine->HasFloats()) {
o = aLine->GetOverflowArea(otype);
o.x, o.y, o.width, o.height,
nsBlockFrame::ReflowInlineFrame(nsBlockReflowState& aState,
(NS_STYLE_CLEAR_NONE != aState.mFloatBreakType), "bad break type");
NS_ASSERTION((NS_STYLE_CLEAR_NONE != breakType) ||
NS_ASSERTION(NS_STYLE_CLEAR_PAGE != breakType, "no page breaks yet");
aLine->SetBreakTypeAfter(breakType);
rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
aLine = mLines.erase(aLine);
while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
line_iterator aLine,
rv = DoReflowInlineFrames(aState, lineLayout, aLine,
line_iterator aLine,
aLine->EnableResizeReflowOptimization();
for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
if (!PlaceLine(aState, aLineLayout, aLine, aFloatStateBeforeLine,
line_iterator       aLine,
IsLastLine(aState, aLine)));
aLine->SetOverflowAreas(overflowAreas);
if (!aLine->CachedIsEmpty()) {
aLine->AppendFloats(aState.mCurrentLineFloats);
if (aLine->HasFloats()) {
o = aLine->GetOverflowArea(otype);
o.x, o.y, o.width, o.height,
0

574 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 363
nsBlockFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
IndentBy(out, aIndent);
ListTag(out);
fprintf(out, " [parent=%p]", mParent);
fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
void* IBprevsibling = Properties().Get(IBSplitSpecialPrevSibling());
fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
0

581 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp cfunc 1645
for (line_iterator line = begin_lines(), line_end = end_lines();
if (gNoisyReflow && !line->IsDirty()) {
static_cast<void*>(line.get()),
static_cast<void*>((line.next() != end_lines() ? line.next().get() : nullptr)),
line->IsBlock() ? "block" : "inline",
line->HasBreakAfter() ? "has-break-after " : "",
line->HasFloats() ? "has-floats " : "",
line->IsImpactedByFloat() ? "impacted " : "",
line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
line->IsImpactedByFloat() ||
line->ResizeReflowOptimizationDisabled() ||
((isLastLine || !line->IsLineWrapped()) && !skipLastLine) ||
(!isLastLine && !line->HasBreakAfter()) ||
line->HasFloats() ||
if (line->IsBlock() ||
line->IsImpactedByFloat() ||
line->MarkDirty();
if (!line->IsBlock()) {
line.get(), line->IsImpactedByFloat() ? "" : "not ");
0

13052 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13053 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13772 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
fc = func(fc);
static nsFloatCache * func(const nsFloatCache * fc)
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc;
fc = func(fc);
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13773 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
fc = func(fc);
static nsFloatCache * func(const nsFloatCache * fc)
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc;
fc = func(fc);
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13774 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
fc = func(&fc);
static nsFloatCache * func(nsFloatCache * * ptr)
nsFloatCache * fc = *ptr;
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc;
fc = func(&fc);
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13775 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
fc = func(&fc);
static nsFloatCache * func(nsFloatCache * * ptr)
nsFloatCache * fc = *ptr;
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc;
fc = func(&fc);
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13776 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
void (*funcPtr) (nsFloatCache *) = badSource;
funcPtr(fc);
void badSource(nsFloatCache * fc)
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13777 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
void (*funcPtr) (nsFloatCache *) = badSource;
funcPtr(fc);
void badSource(nsFloatCache * fc)
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13778 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsFloatCache * dataCopy = fc;
nsFloatCache * fc = dataCopy;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13779 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsFloatCache * dataCopy = fc;
nsFloatCache * fc = dataCopy;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13780 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
instead = f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT;
if (instead)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13781 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
instead = f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT;
if (instead)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13782 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13783 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13784 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
nsFloatCache * dataArray[5];
dataArray[2] = fc;
fc = badSource(dataArray);
void badSource(nsFloatCache * dataArray[])
nsFloatCache * fc = dataArray[2];
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return nsFloatCache;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13785 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
nsFloatCache * dataArray[5];
dataArray[2] = fc;
fc = badSource(dataArray);
void badSource(nsFloatCache * dataArray[])
nsFloatCache * fc = dataArray[2];
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return nsFloatCache;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13786 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
unionType myUnion;
myUnion.unionFirst = fc;
nsFloatCache * fc = myUnion.unionSecond;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13787 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
unionType myUnion;
myUnion.unionFirst = fc;
nsFloatCache * fc = myUnion.unionSecond;
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

13788 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
structType myStruct;
myStruct.structFirst = fc;
fc = badSource(myStruct);
void badSource(structType myStruct)
nsFloatCache * fc = myStruct.structFirst;
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
1

13789 CVE-2013-1732/Firefox_20.0.1_CVE_2013_1732_layout_generic_nsBlockFrame.cpp Format_String_Attack 1222
nsHTMLReflowMetrics&     aMetrics,
const nsHTMLReflowState& aReflowState,
DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
aReflowState.availableWidth, aReflowState.availableHeight,
aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
const nsHTMLReflowState *reflowState = &aReflowState;
aReflowState.ComputedHeight() != NS_AUTOHEIGHT &&
ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
if (GetEffectiveComputedHeight(aReflowState) + heightExtras.TopBottom() <=
mutableReflowState = new nsHTMLReflowState(aReflowState);
mutableReflowState->availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState&>(*reflowState));
bool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
autoFloatManager.CreateFloatManager(aPresContext);
if (IsFrameTreeTooDeep(*reflowState, aMetrics, aStatus)) {
bool topMarginRoot, bottomMarginRoot;
IsMarginRoot(&topMarginRoot, &bottomMarginRoot);
nsBlockReflowState state(*reflowState, aPresContext, this, aMetrics,
topMarginRoot, bottomMarginRoot, needFloatManager);
if (RenumberLists(aPresContext)) {
ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
DrainPushedFloats(state);
PrepareResizeReflow(state);
NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
if (HasOutsideBullet() && !mLines.empty() &&
(mLines.front()->IsBlock() ||
(0 == mLines.front()->mBounds.height &&
mLines.front() != mLines.back() &&
mLines.begin().next()->IsBlock()))) {
nsHTMLReflowMetrics metrics;
nsLayoutUtils::LinePosition position;
bool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
nscoord lineTop = havePosition ? position.mTop
: reflowState->mComputedBorderPadding.top;
nsIFrame* bullet = GetOutsideBullet();
ReflowBullet(bullet, state, metrics, lineTop);
NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,"empty bullet took up space");
if (havePosition && !BulletIsEmpty()) {
nsRect bbox = bullet->GetRect();
bbox.y = position.mBaseline - metrics.ascent;
bullet->SetRect(bbox);
CheckFloats(state);
nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
nsAutoTArray<nsIFrame*, 8> lineFloats;
for (line_iterator line = begin_lines(), line_end = end_lines();
line != line_end; ++line) {
if (line->HasFloats()) {
nsFloatCache* fc = line->GetFirstFloat();
structType myStruct;
myStruct.structFirst = fc;
fc = badSource(myStruct);
void badSource(structType myStruct)
nsFloatCache * fc = myStruct.structFirst;
while (fc) {
lineFloats.AppendElement(fc->mFloat);
fc = fc->Next();
return fc
nsAutoTArray<nsIFrame*, 8> storedFloats;
for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
continue;
storedFloats.AppendElement(f);
if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
for (i = 0; i < lineFloats.Length(); ++i) {
printf("Line float: %p\n", lineFloats.ElementAt(i));
for (i = 0; i < storedFloats.Length(); ++i) {
printf("Stored float: %p\n", storedFloats.ElementAt(i));
nscoord bottomEdgeOfChildren;
ComputeFinalSize(*reflowState, state, aMetrics, &bottomEdgeOfChildren);
nsRect areaBounds = nsRect(0, 0, aMetrics.width, aMetrics.height);
ComputeOverflowAreas(areaBounds, reflowState->mStyleDisplay,bottomEdgeOfChildren, aMetrics.mOverflowAreas);
aMetrics.mOverflowAreas.UnionWith(ocBounds);
aMetrics.mOverflowAreas.UnionWith(fcBounds);
0

