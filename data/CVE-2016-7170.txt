52 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 300
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
dpy_cursor_define(s->vga.con, qc);
dx = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
vmsvga_fifo_run(s);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
s->vga.vram_ptr);
dpy_gfx_replace_surface(s->vga.con, surface);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
x = vmsvga_fifo_read(s);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
vmsvga_fifo_run(s);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
x = vmsvga_fifo_read(s);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
vmsvga_cursor_define(s, &cursor);
vmsvga_fifo_read(s);
0

54 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 304
if (x > SVGA_MAX_WIDTH) {
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
const char *name,
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
const char *name,
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
dpy_cursor_define(s->vga.con, qc);
x = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
dx = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/dst", x1, y1, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
vmsvga_fifo_run(s);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
qemu_default_pixman_format(s->new_depth, true);
trace_vmware_setmode(s->new_width, s->new_height, s->new_depth);
s->vga.vram_ptr);
dpy_gfx_replace_surface(s->vga.con, surface);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
int x0, int y0, int x1, int y1, int w, int h)
if (!vmsvga_verify_rect(surface, "vmsvga_copy_rect/src", x0, y0, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
x = vmsvga_fifo_read(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
vmsvga_fifo_run(s);
static inline void vmsvga_update_rect(struct vmsvga_state_s *s,
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
vmsvga_fifo_read(s);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
vmsvga_cursor_define(s, &cursor);
vmsvga_fifo_read(s);
0

139 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 930
static uint32_t vmsvga_value_read(void *opaque, uint32_t address)
printf("%s: Bad register %02x\n", __func__, s->index);
static uint64_t vmsvga_io_read(void *opaque, hwaddr addr, unsigned size)
struct vmsvga_state_s *s = opaque;
case SVGA_IO_MUL * SVGA_VALUE_PORT: return vmsvga_value_read(s, addr);
0

155 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 435
int x0, int y0, int x1, int y1, int w, int h)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int bypp = surface_bytes_per_pixel(surface);
int width = bypp * w;
memmove(ptr[1], ptr[0], width);
0

180 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 372
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
fprintf(stderr, "%s: w was < 0 (%d)\n", name, w);
fprintf(stderr, "%s: w was > %d (%d)\n", name, SVGA_MAX_WIDTH, w);
if (x + w > surface_width(surface)) {
name, surface_width(surface), x, w);
fprintf(stderr, "%s: y was < 0 (%d)\n", name, y);
fprintf(stderr, "%s: y was > %d (%d)\n", name, SVGA_MAX_HEIGHT, y);
if (y + h > surface_height(surface)) {
name, surface_height(surface), y, h);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
x = 0;
y = 0;
w = surface_width(surface);
h = surface_height(surface);
bypl = surface_stride(surface);
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
qemu_default_pixman_format(s->new_depth, true);
trace_vmware_setmode(s->new_width, s->new_height, s->new_depth);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
vmsvga_fifo_run(s);
vmsvga_update_rect_flush(s);
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
memcpy(dst, src, width);
static inline void vmsvga_update_rect(struct vmsvga_state_s *s,
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
rect = &s->redraw_fifo[s->redraw_fifo_first++];
vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
width = surface_bytes_per_pixel(surface) * w;
start = surface_bytes_per_pixel(surface) * x + bypl * y;
src = s->vga.vram_ptr + start;
dst = surface_data(surface) + start;
memcpy(dst, src, width);
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
static inline bool vmsvga_verify_rect(DisplaySurface *surface,
bypl = surface_stride(surface);
width = surface_bytes_per_pixel(surface) * w;
for (line = h; line > 0; line--, src += bypl, dst += bypl) {
memcpy(dst, src, width);
0

201 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 1072
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
printf("%s: Bad register %02x\n", __func__, s->index);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
printf("%s: Bad register %02x\n", __func__, s->index);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
0

209 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 979
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
printf("%s: Bad width: %i\n", __func__, value);
uint64_t data, unsigned size)
vmsvga_value_write(s, addr, data);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
printf("%s: Bad width: %i\n", __func__, value);
0

425 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 429
int x0, int y0, int x1, int y1, int w, int h)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int bypp = surface_bytes_per_pixel(surface);
int width = bypp * w;
memmove(ptr[1], ptr[0], width);
0

466 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 1084
uint64_t data, unsigned size)
vmsvga_bios_write(s, addr, data);
static void vmsvga_bios_write(void *opaque, uint32_t address, uint32_t data)
printf("%s: what are we supposed to do with (%08x)?\n", __func__, data);
0

467 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 481
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
int x, int y, int w, int h)
int width = surface_bytes_per_pixel(surface) * w;
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
x = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {
fprintf(stderr, "%s: x was < 0 (%d)\n", name, x);
fprintf(stderr, "%s: x was > %d (%d)\n", name, SVGA_MAX_WIDTH, x);
if (x + w > surface_width(surface)) {
name, surface_width(surface), x, w);
fprintf(stderr, "%s: y was < 0 (%d)\n", name, y);
fprintf(stderr, "%s: y was > %d (%d)\n", name, SVGA_MAX_HEIGHT, y);
if (y + h > surface_height(surface)) {
name, surface_height(surface), y, h);
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
width = vmsvga_fifo_read(s);
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
uint32_t c, int x, int y, int w, int h)
DisplaySurface *surface = qemu_console_surface(s->vga.con);
int bypl = surface_stride(surface);
int width = surface_bytes_per_pixel(surface) * w;
fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;
dst = fst;
dst += bypl;
memcpy(dst, fst, width);
static inline bool vmsvga_verify_rect(DisplaySurface *surface,
fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;
dst = fst;
memcpy(dst, fst, width);
0

523 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 994
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
printf("%s: Bad bits per pixel: %i bits\n", __func__, value);
uint64_t data, unsigned size)
vmsvga_value_write(s, addr, data);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
printf("%s: Bad bits per pixel: %i bits\n", __func__, value);
0

631 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c cfunc 537
DisplaySurface *surface = qemu_console_surface(s->vga.con);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
struct vmsvga_cursor_definition_s *c)
qc = cursor_alloc(c->width, c->height);
dpy_cursor_define(s->vga.con, qc);
struct vmsvga_cursor_definition_s cursor;
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
cursor.mask[args] = vmsvga_fifo_read_raw(s);
cursor.image[args] = vmsvga_fifo_read_raw(s);
vmsvga_cursor_define(s, &cursor);
struct vmsvga_cursor_definition_s *c)
__func__, c->bpp);
trace_vmware_palette_write(s->index, value);
trace_vmware_value_write(s->index, value);
vmsvga_fifo_run(s);
DisplaySurface *surface = qemu_console_surface(s->vga.con);
s->vga.vram_ptr);
dpy_gfx_replace_surface(s->vga.con, surface);
struct vmsvga_state_s *s = opaque;
vmsvga_value_write(s, addr, data);
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
static inline int vmsvga_fifo_length(struct vmsvga_state_s *s)
len = vmsvga_fifo_length(s);
cursor.id = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read(struct vmsvga_state_s *s)
return le32_to_cpu(vmsvga_fifo_read_raw(s));
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)
uint32_t cmd = s->fifo[CMD(stop) >> 2];
return cmd;
return le32_to_cpu(vmsvga_fifo_read_raw(s));
cursor.id = vmsvga_fifo_read(s);
vmsvga_cursor_define(s, &cursor);
struct vmsvga_cursor_definition_s *c)
__func__, c->bpp);
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
vmsvga_check_size(s);
vmsvga_fifo_run(s);
static void vmsvga_update_display(void *opaque)
vmsvga_check_size(s);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
vmsvga_cursor_define(s, &cursor);
vmsvga_fifo_read(s);
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
trace_vmware_scratch_write(s->index, value);
vmsvga_fifo_run(s);
static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
vmsvga_fifo_read(s);
static void vmsvga_io_write(void *opaque, hwaddr addr,
vmsvga_value_write(s, addr, data);
static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
cursor.id = vmsvga_fifo_read(s);
1

13600 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

13614 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14034 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
componet_len = c.bpp;
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, componet_len);
0

14048 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
componet_len = c.bpp;
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, componet_len);
1

14062 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = func(&s);
uint32_t func(struct vmsvga_state_s **s)
return vmsvga_fifo_read(*s);
cursor.bpp = func(&s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14076 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = func(&s);
uint32_t func(struct vmsvga_state_s **s)
return vmsvga_fifo_read(*s);
cursor.bpp = func(&s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14090 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
structType myStruct;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
myStruct.structFirst = s;
cursor.bpp = func(myStruct);
uint32_t func(structType myStruct)
struct vmsvga_state_s *s = myStruct.structFirst;
return vmsvga_fifo_read(s);
cursor.bpp = func(myStruct);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14104 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
structType myStruct;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
myStruct.structFirst = s;
cursor.bpp = func(myStruct);
uint32_t func(structType myStruct)
struct vmsvga_state_s *s = myStruct.structFirst;
return vmsvga_fifo_read(s);
cursor.bpp = func(myStruct);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14118 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
unionType myUnion;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
myUnion.unionFirst= s;
cursor.bpp = func(myUnion);
uint32_t func(unionType myUnion)
struct vmsvga_state_s *s = myUnion.unionSecond;
return vmsvga_fifo_read(s);
cursor.bpp = func(myUnion);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14132 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
unionType myUnion;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
myUnion.unionFirst= s;
cursor.bpp = func(myUnion);
uint32_t func(unionType myUnion)
struct vmsvga_state_s *s = myUnion.unionSecond;
return vmsvga_fifo_read(s);
cursor.bpp = func(myUnion);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14146 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = func(s);
uint32_t func(struct vmsvga_state_s *s)
return vmsvga_fifo_read(s);
cursor.bpp = func(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14160 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
uint32_t (*funcPtr)(struct vmsvga_state_s *) = badSource;
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = funcPtr(s);
uint32_t badSource(struct vmsvga_state_s *s)
return vmsvga_fifo_read(s);
cursor.bpp = funcPtr(s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14174 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = func(s);
uint32_t func(struct vmsvga_state_s *s)
return vmsvga_fifo_read(s);
cursor.bpp = func(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14188 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = func(s);
uint32_t func(struct vmsvga_state_s *s)
return vmsvga_fifo_read(s);
cursor.bpp = func(s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14202 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
struct vmsvga_cursor_definition_s *dataCopy = c;
c = dataCopy;
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14216 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
struct vmsvga_cursor_definition_s *dataCopy = c;
c = dataCopy;
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14230 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
struct vmsvga_state_s *dataArray[5];
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
dataArray[2] = s;
cursor.bpp = func(dataArray);
uint32_t func(struct vmsvga_state_s *dataArray[])
struct vmsvga_state_s *s = dataArray[2];
return vmsvga_fifo_read(s);
cursor.bpp = func(dataArray);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14244 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
struct vmsvga_state_s *dataArray[5];
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
dataArray[2] = s;
cursor.bpp = func(dataArray);
uint32_t func(struct vmsvga_state_s *dataArray[])
struct vmsvga_state_s *s = dataArray[2];
return vmsvga_fifo_read(s);
cursor.bpp = func(dataArray);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

14252 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
y = vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width >
|| cursor.height >
|| cursor.bpp >
|| SVGA_BITMAP_SIZE(x, y)
> sizeof(cursor.mask) / sizeof(cursor.mask[0])
|| SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
> sizeof(cursor.image) / sizeof(cursor.image[0])) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
0

14262 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c Format_String_Attack 662
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
struct vmsvga_cursor_definition_s cursor;
int x, y, dx, dy, width, height;
y = vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
cursor.id = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
if (cursor.width > 256 ||
cursor.bpp > 32 ||
cursor.height > 256 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;}
vmsvga_cursor_define(s, &cursor);
static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
struct vmsvga_cursor_definition_s *c)
fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",__func__, c->bpp);
1

