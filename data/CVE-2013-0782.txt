151 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp cfunc 275
char *entity = nullptr;
rv = mEntityConverter->ConvertUTF32ToEntity(inUCS4, mEntityVersion, &entity);
if (!entity || (int32_t)strlen(entity) > bufferLength) {
0

13044 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13045 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13710 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
temp = func(temp);
static char * func(const char * temp)
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
return temp;
temp = func(temp);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13711 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
temp = func(temp);
static char * func(const char * temp)
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
return temp;
temp = func(temp);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13712 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
temp = func(&temp);
static char * func(char * * ptr)
char * temp = *ptr;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
return temp;
temp = func(&temp);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13713 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
temp = func(&temp);
static char * func(char * * ptr)
char * temp = *ptr;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
return temp;
temp = func(&temp);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13714 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
void (funcPtr) (char *) = badSource;
funcPtr(temp);
void badSource(char * temp)
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13715 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
void (funcPtr) (char *) = badSource;
funcPtr(temp);
void badSource(char * temp)
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13716 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
char * dataCopy = temp;
char * temp = dataCopy;
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13717 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
char * dataCopy = temp;
char * temp = dataCopy;
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13718 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
instead = *outString + *currentPos;
memcpy(instead, fallbackStr, tempLen);
1

13719 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
instead = *outString + *currentPos;
memcpy(instead, fallbackStr, tempLen);
0

13720 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
if (temp)
*outString = temp;
*bufferLength += tempLen;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13721 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
if (temp)
*outString = temp;
*bufferLength += addLength;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13722 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
char * dataArray[5];
dataArray[2] = temp;
temp = badSource(dataArray);
void badSource(char * dataArray[])
char * temp = dataArray[2];
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
return temp;
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13723 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
char * dataArray[5];
dataArray[2] = temp;
temp = badSource(dataArray);
void badSource(char * dataArray[])
char * temp = dataArray[2];
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
return temp;
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13724 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
unionType myUnion;
myUnion.unionFirst = temp;
char * temp = myUnion.unionSecond;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13725 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
unionType myUnion;
myUnion.unionFirst = temp;
char * temp = myUnion.unionSecond;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

13726 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + 512;
char *dstPtr = (char *) PR_Malloc(bufferLength);
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
structType myStruct;
myStruct.structFirst = temp;
temp = badSource(myStruct);
void badSource(structType myStruct)
char * temp = myStruct.structFirst;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + tempLen);
return temp;
if (temp)
*bufferLength += tempLen;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
1

13727 CVE-2013-0782/Firefox_18.0_CVE_2013_0782_intl_unicharutil_src_nsSaveAsCharset.cpp Buffer_Overflow_boundedcpy 158
int32_t dstLength;
int32_t pos1, pos2;
nsresult saveResult = NS_OK;
rv = mEncoder->GetMaxLength(inString, inStringLength, &dstLength);
if (NS_FAILED(rv)) return rv;
bufferLength = dstLength + RESERVE_FALLBACK_BYTES;
char *dstPtr = (char *) PR_Malloc(bufferLength + 1);
if (!dstPtr)
return NS_ERROR_OUT_OF_MEMORY;
for (pos1 = 0, pos2 = 0; pos1 < inStringLength;)
dstLength = bufferLength - pos2;
NS_ASSERTION(dstLength >= 0, "out of bounds write");
rv = mEncoder->Convert(&inString[pos1], &srcLength, &dstPtr[pos2], &dstLength);
pos1 += srcLength ? srcLength : 1;
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = mEncoder->Finish(&dstPtr[pos2], &dstLength);
if (NS_SUCCEEDED(rv))
pos2 += dstLength;
dstPtr[pos2] = '\0';
rv = HandleFallBack(unMappedChar, &dstPtr, &bufferLength, &pos2, dstLength);
nsSaveAsCharset::HandleFallBack(uint32_t character, char **outString, int32_t *bufferLength, int32_t *currentPos, int32_t estimatedLength)
char fallbackStr[256];
nsresult rv = DoConversionFallBack(character, fallbackStr, 256);
if (NS_SUCCEEDED(rv))
int32_t tempLen = (int32_t) PL_strlen(fallbackStr);
if ((tempLen + estimatedLength) >= (*bufferLength - *currentPos))
int32_t addLength = tempLen + RESERVE_FALLBACK_BYTES;
structType myStruct;
myStruct.structFirst = temp;
temp = badSource(myStruct);
void badSource(structType myStruct)
char * temp = myStruct.structFirst;
char *temp = (char *) PR_Realloc(*outString, *bufferLength + addLength + 1);
return temp;
if (temp)
*bufferLength += addLength;
*outString = temp;
else
*outString = nullptr;
*bufferLength =0;
return NS_ERROR_OUT_OF_MEMORY;
memcpy((*outString + *currentPos), fallbackStr, tempLen);
0

