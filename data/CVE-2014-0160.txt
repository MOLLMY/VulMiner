38 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 773
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
0

39 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1624
unsigned char *selected;
unsigned char selected_len;
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
s->next_proto_negotiated = OPENSSL_malloc(selected_len);
memcpy(s->next_proto_negotiated, selected, selected_len);
0

61 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 413
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
0

68 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 848
unsigned char *buf = NULL;
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
frag = dtls1_hm_fragment_new(frag_len, 0);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
unsigned long frag_len = msg_hdr->frag_len;
frag = dtls1_hm_fragment_new(frag_len, 0);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(frag_len, 0);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
0

75 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1168
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
size -= 2;
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
if (!tls1_process_sigalgs(s, data, dsize))
size -= 2;
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
0

82 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 487
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
0

140 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 711
unsigned char *buf = NULL;
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
memcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
return dtls1_reassemble_fragment(s, msg_hdr, ok);
0

147 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 969
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
ssl_check_for_safari(s, data, limit);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
unsigned short type, size;
static const unsigned char kSafariTLS12ExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
0

149 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 887
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
size_t sol = s->s3->server_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
ret += sol;
int el;
ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
memcpy(ret, cryptopro_ext, 36);
ret += 36;
s2n(TLSEXT_TYPE_heartbeat, ret);
s2n(1, ret);
*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
*(ret++) = SSL_TLSEXT_HB_ENABLED;
const unsigned char *npa;
unsigned int npalen;
r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,
s2n(TLSEXT_TYPE_next_proto_neg, ret);
s2n(npalen, ret);
memcpy(ret, npa, npalen);
0

165 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1424
unsigned char save_write_sequence[8];
memcpy(save_write_sequence, s->s3->write_sequence,
memcpy(s->s3->write_sequence, s->d1->last_write_sequence,
memcpy(s->d1->last_write_sequence, s->s3->write_sequence,
memcpy(s->s3->write_sequence, save_write_sequence,
0

166 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1051
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
sender, slen,
i = s->method->ssl3_enc->final_finish_mac(s,
s->s3->tmp.finish_md);
i = s->method->ssl3_enc->final_finish_mac(s,
memcpy(p, s->s3->tmp.finish_md, i);
OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);
0

179 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 651
frag = NULL;
(unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH;
unsigned char *p =
memcpy(&p[frag->msg_header.frag_off], frag->fragment,
0

181 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 2368
static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,
int eticklen, const unsigned char *sess_id,
int sesslen, SSL_SESSION **psess)
int slen, mlen, renew_ticket = 0;
HMAC_CTX hctx;
EVP_CIPHER_CTX ctx;
HMAC_CTX_init(&hctx);
EVP_CIPHER_CTX_init(&ctx);
&ctx, &hctx, 0);
if (memcmp(etick, tctx->tlsext_tick_key_name, 16))
if (HMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,
|| EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
etick + 16) <= 0) {
mlen = HMAC_size(&hctx);
if (eticklen <= 16 + EVP_CIPHER_CTX_iv_length(&ctx) + mlen) {
eticklen -= mlen;
if (HMAC_Update(&hctx, etick, eticklen) <= 0
if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {
p = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);
eticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);
sdec = OPENSSL_malloc(eticklen);
|| EVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen) <= 0) {
if (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0) {
slen += mlen;
p = sdec;
sess = d2i_SSL_SESSION(NULL, &p, slen);
memcpy(sess->session_id, sess_id, sesslen);
0

214 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 206
buf = (unsigned char *)OPENSSL_malloc(frag_len);
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
unsigned long frag_len = msg_hdr->frag_len;
frag = dtls1_hm_fragment_new(frag_len, 0);
unsigned char wire[DTLS1_HM_HEADER_LENGTH];
struct hm_header_st msg_hdr;
i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, wire,
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
s->d1->next_handshake_write_seq++;
s2n(s->d1->handshake_write_seq, p);
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
s->d1->handshake_write_seq, 0, 0);
unsigned short seq_num,
dtls1_buffer_message(s, 1);
n2l3(data, msg_hdr->msg_len);
n2s(data, msg_hdr->seq);
n2l3(data, msg_hdr->frag_off);
n2l3(data, msg_hdr->frag_len);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr,
return dtls1_reassemble_fragment(s, msg_hdr, ok);
dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)
frag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
static void dtls1_set_message_header_int(SSL *s, unsigned char mt,
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
dtls1_buffer_message(s, 1);
int dtls1_buffer_message(SSL *s, int is_ccs)
frag = dtls1_hm_fragment_new(s->init_num, 0);
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_process_out_of_seq_message(s, &msg_hdr, ok);
msg_hdr->type = *(data++);
dtls1_get_message_header(wire, &msg_hdr);
return dtls1_reassemble_fragment(s, &msg_hdr, ok);
0

218 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 847
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
size_t sol = s->s3->server_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
ret += sol;
int el;
ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
const unsigned char cryptopro_ext[36] = {
memcpy(ret, cryptopro_ext, 36);
0

229 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 364
int tls12_get_req_sig_algs(SSL *s, unsigned char *p)
size_t slen = sizeof(tls12_sigalgs);
memcpy(p, tls12_sigalgs, slen);
0

294 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1287
unsigned char *buf = NULL;
return NULL;
frag->fragment = buf;
(unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));
bitmask =
return NULL;
memset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));
frag->reassembly = bitmask;
return frag;
s->d1->handshake_write_seq = s->d1->next_handshake_write_seq;
s->d1->next_handshake_write_seq++;
s2n(s->d1->handshake_write_seq, p);
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
s->d1->handshake_write_seq, 0, 0);
unsigned short seq_num,
unsigned char *bitmask = NULL;
frag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));
return NULL;
frag->reassembly = bitmask;
return frag;
dtls1_buffer_message(s, 1);
frag = dtls1_hm_fragment_new(s->init_num, 0);
memcpy(frag->fragment, s->init_buf->data, s->init_num);
static void dtls1_set_message_header_int(SSL *s, unsigned char mt,
dtls1_set_message_header_int(s, SSL3_MT_CCS, 0,
dtls1_buffer_message(s, 1);
int dtls1_buffer_message(SSL *s, int is_ccs)
frag = dtls1_hm_fragment_new(s->init_num, 0);
static hm_fragment *dtls1_hm_fragment_new(unsigned long frag_len,
buf = (unsigned char *)OPENSSL_malloc(frag_len);
frag->fragment = buf;
return frag;
frag = dtls1_hm_fragment_new(s->init_num, 0);
memcpy(frag->fragment, s->init_buf->data, s->init_num);
0

299 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1208
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length;
s->session->tlsext_ellipticcurvelist_length =
s->session->tlsext_ellipticcurvelist_length);
0

300 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1203
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
ellipticcurvelist_length);
0

301 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 652
frag = NULL;
al = dtls1_preprocess_fragment(s, &frag->msg_header, max);
static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr,
al = dtls1_preprocess_fragment(s, &frag->msg_header, max);
frag->msg_header.frag_len);
0

305 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 809
unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
s2n(TLSEXT_TYPE_server_name, ret);
s2n(0, ret);
int el;
if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_status_request, ret);
s2n(0, ret);
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(sol + 2, ret);
s2n(sol, ret);
memcpy(ret, s->s3->server_opaque_prf_input, sol);
0

307 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1528
unsigned short size;
n2s(data, size);
s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_next_proto_validate(data, size)) {
if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
unsigned char *data = *p;
n2s(data, length);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
fprintf(stderr,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
0

308 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1521
unsigned short size;
n2s(data, size);
s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
if (!ssl_next_proto_validate(data, size)) {
if (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))
if (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,
unsigned char *data = *p;
n2s(data, length);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
!s->tls_session_ticket_ext_cb(s, data, size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
static char ssl_next_proto_validate(unsigned char *d, unsigned len)
ctx->next_proto_select_cb(s, &selected, &selected_len, data,
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
size,
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
0

309 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1212
fprintf(stderr, "%i ", *(sdata++));
fprintf(stderr, "\n");
fprintf(stderr, "Received extension type %d size %d\n", type, size);
fprintf(stderr,
fprintf(stderr, "\n");
0

310 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1425
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
sizeof(s->s3->write_sequence));
0

311 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1504
struct hm_header_st msg_hdr;
dtls1_get_message_header(wire, &msg_hdr);
dtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)
memset(msg_hdr, 0x00, sizeof(struct hm_header_st));
0

312 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 976
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
ssl_check_for_safari(s, data, limit);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
0

326 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1115
s->session->tlsext_hostname[len] = '\0';
if (strlen(s->session->tlsext_hostname) != len) {
&& strncmp(s->session->tlsext_hostname,
&& strlen(s->session->tlsext_hostname) == len
0

330 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1331
fprintf(stderr, "buffered messge: \ttype = %xx\n", msg_buf->type);
fprintf(stderr, "\t\t\t\t\tlen = %d\n", msg_buf->len);
fprintf(stderr, "\t\t\t\t\tseq_num = %d\n", msg_buf->seq_num);
0

403 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 570
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
ret += sizeof(tls12_sigalgs);
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(col + 2, ret);
s2n(col, ret);
memcpy(ret, s->s3->client_opaque_prf_input, col);
0

408 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1377
header_length = DTLS1_CCS_HEADER_LENGTH;
header_length = DTLS1_HM_HEADER_LENGTH;
frag->msg_header.msg_len + header_length);
0

422 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 692
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
if ((size_t)(limit - ret) < sizeof(tls12_sigalgs) + 6)
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
ret += sizeof(tls12_sigalgs);
size_t col = s->s3->client_opaque_prf_input_len;
s2n(TLSEXT_TYPE_opaque_prf_input, ret);
s2n(col + 2, ret);
s2n(col, ret);
memcpy(ret, s->s3->client_opaque_prf_input, col);
ret += col;
s2n(TLSEXT_TYPE_status_request, ret);
s2n(extlen + idlen + 5, ret);
*(ret++) = TLSEXT_STATUSTYPE_ocsp;
s2n(idlen, ret);
ret += 2;
itmp = i2d_OCSP_RESPID(id, &ret);
s2n(extlen, ret);
i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);
s2n(TLSEXT_TYPE_heartbeat, ret);
s2n(1, ret);
*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
*(ret++) = SSL_TLSEXT_HB_ENABLED;
s2n(TLSEXT_TYPE_next_proto_neg, ret);
s2n(0, ret);
int el;
ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);
s2n(TLSEXT_TYPE_use_srtp, ret);
s2n(el, ret);
if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {
ret += el;
int hlen = ret - (unsigned char *)s->init_buf->data;
hlen -= 5;
hlen = 0x200 - hlen;
hlen -= 4;
hlen = 0;
s2n(TLSEXT_TYPE_padding, ret);
s2n(hlen, ret);
memset(ret, 0, hlen);
ret += hlen;
s2n(TLSEXT_TYPE_padding, ret);
s2n(hlen, ret);
memset(ret, 0, hlen);
0

424 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 555
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->session->tlsext_ticklen;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
s->tlsext_session_ticket->data, ticklen);
ticklen = 0;
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
ret += ticklen;
s2n(TLSEXT_TYPE_signature_algorithms, ret);
s2n(sizeof(tls12_sigalgs) + 2, ret);
s2n(sizeof(tls12_sigalgs), ret);
memcpy(ret, tls12_sigalgs, sizeof(tls12_sigalgs));
0

453 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1211
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
data += size;
n2s(data, size);
fprintf(stderr, "%i ", *(sdata++));
fprintf(stderr, "\n");
fprintf(stderr, "Received extension type %d size %d\n", type, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
ellipticcurvelist_length += (*(sdata++));
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
fprintf(stderr,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ellipticcurvelist_length = (*(sdata++) << 8);
OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {
memcpy(s->session->tlsext_ellipticcurvelist, sdata,
sdata = s->session->tlsext_ellipticcurvelist;
fprintf(stderr, "%i ", *(sdata++));
0

461 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1047
int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)
sender, slen,
i = s->method->ssl3_enc->final_finish_mac(s,
s->s3->tmp.finish_md);
i = s->method->ssl3_enc->final_finish_mac(s,
memcpy(p, s->s3->tmp.finish_md, i);
OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);
0

465 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 463
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
0

483 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1038
d = (unsigned char *)s->init_buf->data;
p = &(d[DTLS1_HM_HEADER_LENGTH]);
memcpy(p, s->s3->tmp.finish_md, i);
0

494 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 543
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
s->tlsext_ellipticcurvelist_length);
ret += s->tlsext_ellipticcurvelist_length;
ticklen = s->tlsext_session_ticket->length;
s->session->tlsext_tick = OPENSSL_malloc(ticklen);
memcpy(s->session->tlsext_tick,
s2n(TLSEXT_TYPE_session_ticket, ret);
s2n(ticklen, ret);
memcpy(ret, s->session->tlsext_tick, ticklen);
0

498 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1176
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
memcpy(s->session->tlsext_ecpointformatlist, sdata,
sdata = s->session->tlsext_ecpointformatlist;
fprintf(stderr, "%i ", *(sdata++));
0

529 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1173
unsigned short type, size;
static const unsigned char kSafariExtensionsBlock[] = {
data += 2;
n2s(data, type);
n2s(data, size);
data += size;
const size_t len1 = sizeof(kSafariExtensionsBlock);
if (memcmp(data, kSafariExtensionsBlock, len1) != 0)
if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)
if (memcmp(data, kSafariExtensionsBlock, len) != 0)
unsigned short size;
ssl_check_for_safari(s, data, limit);
n2s(data, len);
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
n2s(data, dsize);
size -= 2;
memcpy(s->srp_ctx.login, &data[1], len);
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
n2s(data, dsize);
size -= 2;
if (!tls1_process_sigalgs(s, data, dsize))
s->tlsext_status_type = *data++;
size--;
n2s(data, dsize);
size -= 2;
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
id = d2i_OCSP_RESPID(NULL, &sdata, idsize);
data += idsize;
n2s(data, dsize);
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length);
ecpointformatlist_length;
s->session->tlsext_ecpointformatlist_length =
s->session->tlsext_ecpointformatlist_length);
int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,
unsigned char *data = *p;
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length;
s->session->tlsext_ecpointformatlist_length =
s->session->tlsext_ecpointformatlist_length);
static void ssl_check_for_safari(SSL *s, const unsigned char *data,
n2s(data, len);
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length;
s->session->tlsext_ecpointformatlist_length =
s->session->tlsext_ecpointformatlist_length);
int tls1_process_sigalgs(SSL *s, const unsigned char *data, int dsize)
n2s(data, type);
n2s(data, size);
unsigned char *sdata = data;
int ecpointformatlist_length = *(sdata++);
OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
ecpointformatlist_length;
s->session->tlsext_ecpointformatlist_length =
s->session->tlsext_ecpointformatlist_length);
0

567 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1363
(frag->msg_header.seq,
frag->msg_header.is_ccs), 0,
int dtls1_get_queue_priority(unsigned short seq, int is_ccs)
return seq * 2 - is_ccs;
(frag->msg_header.seq,
dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
fprintf(stderr, "retransmit:  message %d non-existant\n", seq);
0

570 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1037
unsigned short type;
n2s(data, type);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
int idsize;
n2s(data, idsize);
size -= 2 + idsize;
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
0

571 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 1139
unsigned short size;
n2s(data, size);
fprintf(stderr, "Received extension type %d size %d\n", type, size);
s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);
size -= 2;
!s->tls_session_ticket_ext_cb(s, data, size,
if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))
size -= 2;
size--;
size -= 2;
size -= 2 + idsize;
size -= 2;
if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))
data += size;
n2s(data, type);
n2s(data, size);
s->srp_ctx.login[len] = '\0';
if (strlen(s->srp_ctx.login) != len)
memcpy(s->srp_ctx.login, &data[1], len);
0

580 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 510
unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
unsigned char *ret = buf;
ret += 2;
long lenmax;
strlen(s->tlsext_hostname)) > (unsigned long)lenmax)
s2n(TLSEXT_TYPE_server_name, ret);
s2n(size_str + 5, ret);
s2n(size_str + 3, ret);
*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
s2n(size_str, ret);
memcpy(ret, s->tlsext_hostname, size_str);
ret += size_str;
int el;
if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
s2n(TLSEXT_TYPE_renegotiate, ret);
s2n(el, ret);
if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
ret += el;
int login_len = strlen(s->srp_ctx.login);
s2n(TLSEXT_TYPE_srp, ret);
s2n(login_len + 1, ret);
(*ret++) = (unsigned char)login_len;
memcpy(ret, s->srp_ctx.login, login_len);
ret += login_len;
s2n(TLSEXT_TYPE_ec_point_formats, ret);
s2n(s->tlsext_ecpointformatlist_length + 1, ret);
*(ret++) = (unsigned char)s->tlsext_ecpointformatlist_length;
memcpy(ret, s->tlsext_ecpointformatlist,
s->tlsext_ecpointformatlist_length);
ret += s->tlsext_ecpointformatlist_length;
s2n(TLSEXT_TYPE_elliptic_curves, ret);
s2n(s->tlsext_ellipticcurvelist_length + 2, ret);
s2n(s->tlsext_ellipticcurvelist_length, ret);
memcpy(ret, s->tlsext_ellipticcurvelist,
0

623 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c cfunc 2610
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

671 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c cfunc 1592
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;

payload + padding;
unsigned int write_length =
buffer = OPENSSL_malloc(write_length);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

13070 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13071 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13592 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

13606 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
0

13932 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
buffer = func(buffer);
static char * func(const char * buffer)
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
return buffer;
buffer = func(buffer);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13933 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
buffer = func(buffer);
static char * func(const char * buffer)
buffer = OPENSSL_malloc(write_length);
return buffer;
buffer = func(buffer);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13934 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
buffer = func(&buffer);
static char * func(char * * ptr)
cahr * buffer = *ptr
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
return buffer;
buffer = func(*buffer);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13935 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
buffer = func(&buffer);
static char * func(char * * ptr)
buffer = OPENSSL_malloc(write_length);
return buffer;
buffer = func(&buffer);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13936 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
void (*funcPtr) (char *) = badsource;
funcPtr(buffer)
void badsource(char * buffer)
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13937 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
void (*funcPtr) (char *) = badsource;
funcPtr(buffer)
void badsource(char * buffer)
buffer = OPENSSL_malloc(write_length);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13938 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
char * datacopy = buffer;
cahr * buffer = datacopy;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13939 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
buffer = OPENSSL_malloc(write_length);
char * datacopy = buffer;
cahr * buffer = datacopy;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13940 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
len = 3 + payload + padding;
buffer = OPENSSL_malloc(len);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, len);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, len,
s, s->msg_callback_arg);
1

13941 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
if (3 + payload + padding; > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
buffer = OPENSSL_malloc(3 + payload + padding;);
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding;);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding;,
s, s->msg_callback_arg);
0

13942 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
int r;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13943 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13944 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
cahr * dataArray[5];
dataArray[2] = buffer;
buffer = badsource(dataArray);
void badsource(char * dataArray[])
cahr * buffer = dataArray[2];
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
reruen buffer;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13945 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
cahr * dataArray[5];
dataArray[2] = buffer;
buffer = badsource(dataArray);
void badsource(char * dataArray[])
cahr * buffer = dataArray[2];
buffer = OPENSSL_malloc(write_length);
return buffer;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13946 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
unionType myUnion;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
myUnion.unionFirst = buffer;
char * buffer = myUnion.unionSecond;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13947 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
unionType myUnion;
buffer = OPENSSL_malloc(write_length);
myUnion.unionFirst = buffer;
char * buffer = myUnion.unionSecond;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

13948 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
hbtype = *p++;
n2s(p, payload);
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
int r;
structType myStruct;
myStruct.structFirst = buffer;
buffer = badsource(myStruct);
void badsource(structType myStruct)
char * buffer = myStruct.structFirst;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
return buffer;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, 3 + payload + padding,
s, s->msg_callback_arg);
1

13949 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_d1_both.c Buffer_Overflow_boundedcpy 1550
unsigned int payload;
unsigned int padding = 16;
if (1 + 2 + 16 > s->s3->rrec.length)
return 0;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
if (hbtype == TLS1_HB_REQUEST)
unsigned char *buffer, *bp;
unsigned int write_length =

payload + padding;
int r;
if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
return 0;
structType myStruct;
myStruct.structFirst = buffer;
buffer = badsource(myStruct);
void badsource(structType myStruct)
char * buffer = myStruct.structFirst;
buffer = OPENSSL_malloc(write_length);
return buffer;
bp = buffer;
r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
if (r >= 0 && s->msg_callback)
s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
buffer, write_length,
s, s->msg_callback_arg);
0

14026 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
componet_len = write_count;
buffer = OPENSSL_malloc(componet_len);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14040 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
componet_len = 1 + 2 + payload;
buffer = OPENSSL_malloc(componet_len + padding);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14054 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
bp = func(&bp)
static unsigned char* func(unsigned char**bptr)
unsigned  char *bp = *bptr;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(&bp)
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14068 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
bp = func(&bp)
static unsigned char* func(unsigned char**bptr)
unsigned  char *bp = *bptr;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(&bp)
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14082 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
structType myStruct;
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
myStruct.structFirst = bp;
bp = func(myStruct)
static unsigned char* func(structType myStruct)
unsigned char* bp = myStruct.structFirst;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(myStruct)
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14096 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
structType myStruct;
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
myStruct.structFirst = bp;
bp = func(myStruct)
static unsigned char* func(structType myStruct)
unsigned char* bp = myStruct.structFirst;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(myStruct)
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14110 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unionType myUnion;
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
myUnion.unionFirst = bp;
bp = func(myUnion);
static unsigned char* func(unionType myUnion)
unsigned char* bp = myUnion.unionSecond;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(myUnion)
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14124 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unionType myUnion;
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
myUnion.unionFirst = bp;
bp = func(myUnion);
static unsigned char* func(unionType myUnion)
unsigned char* bp = myUnion.unionSecond;
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(myUnion)
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14138 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = func(bp)
static unsigned char* func(const unsigned char*bp)
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(bp)
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14152 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
static unsigned char* (*funcPtr)(unsigned char*)  = badSource;
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
bp = funcPtr(bp)
static unsigned char* badSource(unsigned char *bp)
*bp++ = TLS1_HB_RESPONSE
return bp
bp = funcPtr(bp)
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14166 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
bp = func(bp)
static unsigned char* func(const unsigned char*bp)
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(bp)
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14180 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
bp = func(bp)
static unsigned char* func(const unsigned char*bp)
*bp++ = TLS1_HB_RESPONSE
return bp
bp = func(bp)
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14194 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
unsigned char *dataCopy = buffer;
bp = dataCopy;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14208 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
unsigned char *dataCopy = buffer;
bp = dataCopy;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14222 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
unsigned char *dataArray[5];
buffer = OPENSSL_malloc(write_length);
bp = buffer;
dataArray[2] = bp;
bp = func(dataArray);
static unsigned char* func(unsigned char *dataArray[])
*bp = dataArray[2];
*bp++ = TLS1_HB_RESPONSE;
return bp;
bp = func(dataArray);
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14236 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned char *p = &s->s3->rrec.data[0], *pl;
unsigned int padding = 16;
unsigned int payload;
unsigned char *buffer, *bp;
hbtype = *p++;
n2s(p, payload);
pl = p;
unsigned char *dataArray[5];
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
dataArray[2] = bp;
bp = func(dataArray);
static unsigned char* func(unsigned char *dataArray[])
*bp = dataArray[2];
*bp++ = TLS1_HB_RESPONSE;
return bp;
bp = func(dataArray);
s2n(payload, bp);
memcpy(bp, pl, payload);
1

14250 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned int payload;
unsigned int padding = 16;
unsigned char *buffer, *bp;
unsigned char *p = &s->s3->rrec.data[0], *pl;
hbtype = *p++;
n2s(p, payload);
if (1 + 2 + payload + 16 > s->s3->rrec.length)
return 0;
pl = p;
buffer = OPENSSL_malloc(write_length);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
0

14258 CVE-2014-0160/OpenSSL_1.0.1_CVE-2014-0160_t1_lib.c Buffer_Overflow_boundedcpy 2578
int tls1_process_heartbeat(SSL *s)
unsigned int payload;
unsigned int padding = 16;
unsigned char *buffer, *bp;
unsigned char *p = &s->s3->rrec.data[0], *pl;
hbtype = *p++;
n2s(p, payload);
pl = p;
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;
*bp++ = TLS1_HB_RESPONSE;
s2n(payload, bp);
memcpy(bp, pl, payload);
1

