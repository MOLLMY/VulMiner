168 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 324
nullptr, nullptr, nullptr);
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
0

169 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 324
nullptr, nullptr, nullptr);
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
0

198 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 273
RawReader(png_structp png_ptr, png_bytep data, png_size_t length)
RawReadState *state = (RawReadState *)png_get_io_ptr(png_ptr);
memcpy(data, state->start + state->offset, length);
0

477 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 521
const char *mBuf;
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
return sizeof(local_file_header) + letoh16(filename_size) +
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
int32_t width, height, fps;
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
0

585 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 624
uint16_t len = letoh16(entry->filename_size);
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
const char *mBuf;
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
return nullptr;
while ((entry = reader.GetNextEntry(entry))) {
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
memcpy(vaddr, frame.buf,
gettimeofday(&tv2, nullptr);
frame.buf = nullptr;
free(frame.buf);
string GetEntryName(const cdir_entry *entry)
string name = reader.GetEntryName(entry);
file = reader.GetLocalEntry(entry);
const local_file_header * GetLocalEntry(const cdir_entry *entry)
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
free(frame.buf);
1

586 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 624
uint16_t len = letoh16(entry->filename_size);
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
const char *mBuf;
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
return nullptr;
while ((entry = reader.GetNextEntry(entry))) {
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
memcpy(vaddr, frame.buf,
gettimeofday(&tv2, nullptr);
frame.buf = nullptr;
free(frame.buf);
string GetEntryName(const cdir_entry *entry)
string name = reader.GetEntryName(entry);
file = reader.GetLocalEntry(entry);
const local_file_header * GetLocalEntry(const cdir_entry *entry)
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
free(frame.buf);
1

587 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 584
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
letoh16(extra_field_size) + GetDataSize();
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
if (((char *)data + data->GetSize()) > (char *)mEnd)
return nullptr;
return data;
color.g8 = color16.green;
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
((color.g8 & 0xFC) << 3) |
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
return (color565 << 16) | color565;
while ((entry = reader.GetNextEntry(entry))) {
file = reader.GetLocalEntry(entry);
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return letoh32(compressed_size);
color.b8 = color16.blue;
return color.r8g8b8;
return color.r8g8b8;
((color.g8 & 0xFC) << 3) |
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
((color.b8       ) >> 3);
((color.g8 & 0xFC) << 3) |
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
return (color565 << 16) | color565;
return 0;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
} while (end && *(line = end + 1));
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
void *vaddr;
0, 0, width, height, &vaddr)) {
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill,
AsBackgroundFill(const png_color_16& color16, int outputFormat)
color.r8 = color16.red;
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
((color.g8 & 0xFC) << 3) |
uint16_t color565 = ((color.r8 & 0xF8) << 8) |
return (color565 << 16) | color565;
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill,
1

588 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 536
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
return nullptr;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
letoh16(extra_field_size) + letoh16(file_comment_size);
const char *mBuf;
entry = (cdir_entry *)((char *)prev + prev->GetSize());
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
if (name.find(search) ||
1

598 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 547
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
name.append(entry->data, len);
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
uint16_t len = letoh16(entry->filename_size);
if (((char *)data + data->GetSize()) > (char *)mEnd)
return nullptr;
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
const char *mBuf;
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
madvise(mBuf, sb.st_size, MADV_SEQUENTIAL);
mBuf = nullptr;
entry = (cdir_entry *)((char *)prev + prev->GetSize());
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
sort(part.frames.begin(), part.frames.end());
string GetEntryName(const cdir_entry *entry)
string name = reader.GetEntryName(entry);
while ((entry = reader.GetNextEntry(entry))) {
file = reader.GetLocalEntry(entry);
const local_file_header * GetLocalEntry(const cdir_entry *entry)
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
sort(part.frames.begin(), part.frames.end());
const cdir_entry * GetNextEntry(const cdir_entry *prev)
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
sort(part.frames.begin(), part.frames.end());
1

601 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 431
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
letoh16(extra_field_size) + GetDataSize();
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return nullptr;
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
const char *mBuf;
entry = (cdir_entry *)((char *)prev + prev->GetSize());
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
AsBackgroundFill(const png_color_16& color16, int outputFormat)
color.b8 = color16.blue;
color.r8 = color16.red;
swap(color.r8, color.b8);
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
1

643 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 589
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
letoh16(extra_field_size) + GetDataSize();
uint16_t len = letoh16(entry->filename_size);
return nullptr;
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
const char *mBuf;
entry = (cdir_entry *)((char *)prev + prev->GetSize());
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
if (((char *)data + data->GetSize()) > (char *)mEnd)
return data;
file = reader.GetLocalEntry(entry);
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
void *vaddr;
0, 0, width, height, &vaddr)) {
memcpy(vaddr, frame.buf,
string GetEntryName(const cdir_entry *entry)
string name = reader.GetEntryName(entry);
file = reader.GetLocalEntry(entry);
const local_file_header * GetLocalEntry(const cdir_entry *entry)
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
memcpy(vaddr, frame.buf,
1

650 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 524
string GetEntryName(const cdir_entry *entry)
string name = reader.GetEntryName(entry);
while ((entry = reader.GetNextEntry(entry))) {
file = reader.GetLocalEntry(entry);
const cdir_entry * GetNextEntry(const cdir_entry *prev)
entry = (cdir_entry *)((char *)prev + prev->GetSize());
return sizeof(cdir_entry) + letoh16(filename_size) +
entry = (cdir_entry *)((char *)prev + prev->GetSize());
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
const local_file_header * GetLocalEntry(const cdir_entry *entry)
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
return sizeof(local_file_header) + letoh16(filename_size) +
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
struct stat sb;
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
mBuf = nullptr;
uint16_t len = letoh16(entry->filename_size);
name.append(entry->data, len);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
1

664 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cfunc 386
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
const char *mBuf;
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return nullptr;
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
entry = (cdir_entry *)((char *)prev + prev->GetSize());
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
nullptr, nullptr, nullptr);
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
png_set_read_fn(pngread, &state, RawReader);
png_set_keep_unknown_chunks(pngread, 1, unused_chunks,
png_set_keep_unknown_chunks(pngread, 1, tRNS_chunk, 1);
png_read_info(pngread, pnginfo);
has_bgcolor = (PNG_INFO_bKGD == png_get_bKGD(pngread, pnginfo, &colorp));
width = png_get_image_width(pngread, pnginfo);
height = png_get_image_height(pngread, pnginfo);
bytepp = 4;
bytepp = 3;
bytepp = 2;
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
frame.ReadPngFrame(format);
buf = (char *)malloc(width * (height + 1) * bytepp);
1

665 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp cppfunc 386
return letoh32(uncompressed_size);
return sizeof(local_file_header) + letoh16(filename_size) +
const char *mBuf;
(local_file_header *)(mBuf + letoh32(entry->offset));
const local_file_header * data =
if (((char *)data + data->GetSize()) > (char *)mEnd)
letoh16(extra_field_size) + GetDataSize();
if (((char *)data + data->GetSize()) > (char *)mEnd)
return nullptr;
return data;
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
return data + letoh16(filename_size) + letoh16(extra_field_size);
return sizeof(cdir_entry) + letoh16(filename_size) +
letoh16(extra_field_size) + letoh16(file_comment_size);
entry = (cdir_entry *)((char *)prev + prev->GetSize());
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return nullptr;
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
return data;
nullptr, nullptr, nullptr);
png_structp pngread = png_create_read_struct(PNG_LIBPNG_VER_STRING,
png_infop pnginfo = png_create_info_struct(pngread);
if (setjmp(png_jmpbuf(pngread))) {
png_set_read_fn(pngread, &state, RawReader);
png_set_keep_unknown_chunks(pngread, 1, unused_chunks,
png_set_keep_unknown_chunks(pngread, 1, tRNS_chunk, 1);
png_read_info(pngread, pnginfo);
has_bgcolor = (PNG_INFO_bKGD == png_get_bKGD(pngread, pnginfo, &colorp));
width = png_get_image_width(pngread, pnginfo);
file = reader.GetLocalEntry(entry);
descCopy.append(file->GetData(), entry->GetDataSize());
height = png_get_image_height(pngread, pnginfo);
bytepp = 4;
bytepp = 3;
bytepp = 2;
string descCopy;
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
vector<AnimationPart> parts;
end = strstr(line, "\n");
} while (end && *(line = end + 1));
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
frame.ReadPngFrame(format);
buf = (char *)malloc(width * (height + 1) * bytepp);
1

13099 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13100 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13101 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13102 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13103 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
0

13104 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
0

13137 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13138 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13139 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13140 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13141 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
1

13142 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
1

13175 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
component_data = sizeof(search);
snprintf(search, component_data, "%s/", part.path);
0

13176 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
component_data = sizeof(wchar_t);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / component_data);
0

13177 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
component_data = frame.width * frame.height;
memcpy(vaddr, frame.buf, component_data * frame.bytepp);
0

13178 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
component_data = src_stride;
memcpy(dst, src, component_data);
0

13179 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
component_data = name.c_str();
strcpy(frame.path, component_data);
0

13212 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
component_data = sizeof(search);
snprintf(search, component_data, "%s/", part.path);
1

13213 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
component_data = sizeof(wchar_t);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / component_data);
1

13214 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
component_data = frame.width * frame.height * frame.bytepp);
memcpy(vaddr, frame.buf, component_data);
1

13215 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
component_data = src_stride;
memcpy(dst, src, component_data);
1

13216 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
component_data = name.c_str();
strcpy(frame.path, component_data);
1

13231 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = func(parts, &i);
AnimationPart func(vector<AnimationPart>& parts, uint32_t *i)
return parts[*i];
AnimationPart &part = func(parts, &i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13232 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = func(part, &k);
AnimationFrame func(AnimationPart& part, uint32_t *k)
return part.frames[*k];
AnimationFrame &frame = func(part, &k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13233 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = func(part, &k);
AnimationFrame func(AnimationPart& part, uint32_t *k)
return part.frames[*k];
AnimationFrame &frame = func(part, &k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13234 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = func(&frame);
char* func(AnimationFrame *&frame)
return frame->buf;
char *src = func(&frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13235 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = func(&part);
AnimationFrame func(AnimationPart *&part)
return part->frames.back();
AnimationFrame &frame = func(&part);
strcpy(frame.path, name.c_str());
1

13250 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = func(parts, &i);
AnimationPart func(vector<AnimationPart>& parts, uint32_t *i)
return parts[*i];
AnimationPart &part = func(parts, &i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13251 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = func(part, &k);
AnimationFrame func(AnimationPart& part, uint32_t *k)
return part.frames[*k];
AnimationFrame &frame = func(part, &k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13252 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = func(part, &k);
AnimationFrame func(AnimationPart& part, uint32_t *k)
return part.frames[*k];
AnimationFrame &frame = func(part, &k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13253 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = func(&frame);
char* func(AnimationFrame *&frame)
return frame->buf;
char *src = func(&frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13254 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = func(&part);
AnimationFrame func(AnimationPart *&part)
return part->frames.back();
AnimationFrame &frame = func(&part);
strcpy(frame.path, name.c_str());
0

13269 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
vector<AnimationPart> dataArray[5];
dataArray[2] = parts;
AnimationPart &part = goodSource(dataArray, i);
AnimationPart goodSource(vector<AnimationPart> dataArray[], uint32_t i)
vector<AnimationPart> &parts = dataArray[2];
return parts[i];
AnimationPart &part = goodSource(dataArray, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13270 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame dataArray[5];
dataArray[2] = part;
AnimationFrame &frame = goodSource(dataArray, k);
AnimationFrame goodSource(AnimationFrame dataArray[], uint32_t k)
AnimationFrame &part = dataArray[2];
return part.frames[k];
AnimationFrame &frame = goodSource(dataArray, k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13271 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationPart dataArray[5];
dataArray[2] = part;
AnimationFrame &frame = goodSource(dataArray, k);
AnimationFrame goodSource(AnimationFrame dataArray, uint32_t k)
AnimationFrame &part = dataArray[2];
return part.frames[k];
AnimationFrame &frame = goodSource(dataArray, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13272 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *dataArray[5];
dataArray[2] = frame.buf;
char *src = goodSource(dataArray);
char* goodSource(char *dataArray)
char *tmp = dataArray[2];
return tmp;
char *src = goodSource(dataArray);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13273 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
vector<AnimationPart> dataArray[5];
dataArray[2] = parts;
AnimationPart &part = goodSource(dataArray);
AnimationPart goodSource(vector<AnimationPart> dataArray[])
vector<AnimationPart> &parts = dataArray[i];
return  parts[i];
AnimationPart &part = goodSource(dataArray);
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
0

13287 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
vector<AnimationPart> dataArray[5];
dataArray[2] = parts;
AnimationPart &part = badSource(dataArray, i);
AnimationPart badSource(vector<AnimationPart> dataArray[], uint32_t i)
vector<AnimationPart> &parts = dataArray[2];
return parts[i];
AnimationPart &part = badSource(dataArray, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13288 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame dataArray[5];
dataArray[2] = part;
AnimationFrame &frame = badSource(dataArray, k);
AnimationFrame badSource(AnimationFrame dataArray[], uint32_t k)
AnimationFrame &part = dataArray[2];
return part.frames[k];
AnimationFrame &frame = badSource(dataArray, k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13289 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationPart dataArray[5];
dataArray[2] = part;
AnimationFrame &frame = badSource(dataArray, k);
AnimationFrame badSource(AnimationFrame dataArray, uint32_t k)
AnimationFrame &part = dataArray[2];
return part.frames[k];
AnimationFrame &frame = badSource(dataArray, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13290 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *dataArray[5];
dataArray[2] = frame.buf;
char *src = badSource(dataArray);
char* badSource(char *dataArray)
char *tmp = dataArray[2];
return tmp;
char *src = badSource(dataArray);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13291 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
vector<AnimationPart> dataArray[5];
dataArray[2] = parts;
AnimationPart &part = badSource(dataArray);
AnimationPart badSource(vector<AnimationPart> dataArray[])
vector<AnimationPart> &parts = dataArray[i];
return  parts[i];
AnimationPart &part = badSource(dataArray);
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
1

13312 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
AnimationPart (*funcPtr)(vector<AnimationPart>& , uint32_t ) = goodSource;
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = funcPtr(parts, i);
AnimationPart goodSource(vector<AnimationPart>& parts, uint32_t i)
return parts[i];
AnimationPart &part = funcPtr(parts, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13313 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
AnimationFrame (*funcPtr)(AnimationPart&, uint32_t) = goodSource;
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationFrame &frame = funcPtr(part, k);
AnimationFrame goodSource(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = funcPtr(part, k);
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13314 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
AnimationFrame (*funcPtr)(AnimationPart& , uint32_t) = goodSource;
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = funcPtr(part, k);
AnimationFrame goodSource(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = funcPtr(part, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13315 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
char* (*funcPtr)(AnimationFrame &) = goodSource;
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = funcPtr(frame);
char* goodSource(AnimationFrame &frame)
return frame.buf;
char *src = funcPtr(frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13316 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
AnimationFrame (*funcPtr)(AnimationPart &) = goodSource;
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = funcPtr(part);
AnimationFrame goodSource(AnimationPart &part)
return part.frames.back();
AnimationFrame &frame = funcPtr(part);
strcpy(frame.path, name.c_str());
0

13338 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
AnimationPart (*funcPtr)(vector<AnimationPart>& , uint32_t ) = badSource;
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = funcPtr(parts, i);
AnimationPart badSource(vector<AnimationPart>& parts, uint32_t i)
return parts[i];
AnimationPart &part = funcPtr(parts, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13339 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
AnimationFrame (*funcPtr)(AnimationPart&, uint32_t) = badSource;
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = funcPtr(part, k);
AnimationFrame badSource(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = funcPtr(part, k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13340 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
AnimationFrame (*funcPtr)(AnimationPart& , uint32_t) = badSource;
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = funcPtr(part, k);
AnimationFrame badSource(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = funcPtr(part, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13341 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
char* (*funcPtr)(AnimationFrame &) = badSource;
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = funcPtr(frame);
char* badSource(AnimationFrame &frame)
return frame.buf;
char *src = funcPtr(frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13342 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
AnimationFrame (*funcPtr)(AnimationPart &) = badSource;
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = funcPtr(part);
AnimationFrame badSource(AnimationPart &part)
return part.frames.back();
AnimationFrame &frame = funcPtr(part);
strcpy(frame.path, name.c_str());
1

13364 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = func(parts, i);
AnimationPart func(vector<AnimationPart>& parts, uint32_t i)
return parts[i];
AnimationPart &part = func(parts, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13365 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = func(part, k);
AnimationFrame func(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = func(part, k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13366 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = func(part, k);
AnimationFrame func(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = func(part, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13367 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = func(frame);
char* func(AnimationFrame &frame)
return frame.buf;
char *src = func(frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13368 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = func(part);
AnimationFrame func(AnimationPart &part)
return part.frames.back();
AnimationFrame &frame = func(part);
strcpy(frame.path, name.c_str());
0

13390 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = func(parts, i);
AnimationPart func(vector<AnimationPart>& parts, uint32_t i)
return parts[i];
AnimationPart &part = func(parts, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13391 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = func(part, k);
AnimationFrame func(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = func(part, k);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13392 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = func(part, k);
AnimationFrame func(AnimationPart& part, uint32_t k)
return part.frames[k];
AnimationFrame &frame = func(part, k);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13393 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = func(frame);
char* func(AnimationFrame &frame)
return frame.buf;
char *src = func(frame);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13394 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = func(part);
AnimationFrame func(AnimationPart &part)
return part.frames.back();
AnimationFrame &frame = func(part);
strcpy(frame.path, name.c_str());
1

13427 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
char* dataType = search;
search = dataType;
snprintf(search, sizeof(search), "%s/", part.path);
0

13428 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
ANativeWindowBuffer *dataType = buf;
buf = dataType;
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13429 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
AnimationFrame *dataType = &frame;
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
AnimationFrame frame = *dataType;
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13430 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char* dataType = src;
src = dataType;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13431 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
AnimationPart *dataType = &part;
part = *dataType;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
0

13432 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationPart *dataType = &part;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
part = *dataType;
strcpy(frame.path, name.c_str());
0

13465 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
char* dataType = search;
search = dataType;
snprintf(search, sizeof(search), "%s/", part.path);
1

13466 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
ANativeWindowBuffer *dataType = buf;
buf = dataType;
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13467 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
AnimationFrame *dataType = &frame;
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;  }
AnimationFrame frame = *dataType;
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13468 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char* dataType = src;
src = dataType;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13469 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
AnimationPart *dataType = &part;
part = *dataType;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
1

13470 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationPart *dataType = &part;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
part = *dataType;
strcpy(frame.path, name.c_str());
1

13485 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
structType myStruct;
myStruct.structFirst = parts;
AnimationPart &part = func(myStruct, i);
AnimationPart func(structType &myStruct, uint32_t i)
parts = myStruct.structFirst;
return parts[i];
AnimationPart &part = func(myStruct, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13486 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
structType myStruct;
myStruct.structFirst = k;
AnimationFrame &frame = func(part, myStruct);
AnimationFrame func(AnimationPart& part, structType myStruct)
uint32_t k = myStruct.structFirst;
return part.frames[k];
AnimationFrame &frame = func(part, myStruct);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13487 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
structType myStruct;
myStruct.structFirst = k;
AnimationFrame &frame = func(part, myStruct);
AnimationFrame func(AnimationPart& part, structType myStruct)
uint32_t k = myStruct.structFirst;
return part.frames[k];
AnimationFrame &frame = func(part, myStruct);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13488 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
structType myStruct;
myStruct.structFirst = frame;
char *src = func(myStruct);
char* func(structType &myStruct)
AnimationFrame &frame = myStruct.structFirst;
return frame.buf;
char *src = func(myStruct);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13489 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
structType myStruct;
myStruct.structFirst = part;
AnimationFrame &frame = func(myStruct);
AnimationFrame func(structType &myStruct)
AnimationPart &part = myStruct.structFirst;
return part.frames.back();
AnimationFrame &frame = func(myStruct);
strcpy(frame.path, name.c_str());
0

13503 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
structType myStruct;
myStruct.structFirst = parts;
AnimationPart &part = func(myStruct, i);
AnimationPart func(structType &myStruct, uint32_t i)
parts = myStruct.structFirst;
return parts[i];
AnimationPart &part = func(myStruct, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13504 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
structType myStruct;
myStruct.structFirst = k;
AnimationFrame &frame = func(part, myStruct);
AnimationFrame func(AnimationPart& part, structType myStruct)
uint32_t k = myStruct.structFirst;
return part.frames[k];
AnimationFrame &frame = func(part, myStruct);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13505 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
structType myStruct;
myStruct.structFirst = k;
AnimationFrame &frame = func(part, myStruct);
AnimationFrame func(AnimationPart& part, structType myStruct)
uint32_t k = myStruct.structFirst;
return part.frames[k];
AnimationFrame &frame = func(part, myStruct);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13506 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
structType myStruct;
myStruct.structFirst = frame;
char *src = func(myStruct);
char* func(structType &myStruct)
AnimationFrame &frame = myStruct.structFirst;
return frame.buf;
char *src = func(myStruct);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13507 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
structType myStruct;
myStruct.structFirst = part;
AnimationFrame &frame = func(myStruct);
AnimationFrame func(structType &myStruct)
AnimationPart &part = myStruct.structFirst;
return part.frames.back();
AnimationFrame &frame = func(myStruct);
strcpy(frame.path, name.c_str());
1

13521 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
unionType myUnion;
myUnion.unionFirst = parts;
AnimationPart &part = func(myUnion, i);
AnimationPart func(unionType &myUnion, uint32_t i)
parts = myUnion.unionSecond;
return parts[i];
AnimationPart &part = func(myUnion, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13522 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
unionType myUnion;
myUnion.unionFirst = k;
AnimationFrame &frame = func(part, myUnion);
AnimationFrame func(AnimationPart& part, unionType myUnion)
uint32_t k = myUnion.unionSecond;
return part.frames[k];
AnimationFrame &frame = func(part, myUnion);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13523 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
unionType myUnion;
myUnion.unionFirst = k;
AnimationFrame &frame = func(part, myUnion);
AnimationFrame func(AnimationPart& part, unionType myUnion)
uint32_t k = myUnion.unionSecond;
return part.frames[k];
AnimationFrame &frame = func(part, myUnion);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13524 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
unionType myUnion;
myUnion.unionFirst = frame;
char *src = func(myUnion);
char* func(unionType &myUnion)
AnimationFrame &frame = myUnion.unionSecond;
return frame.buf;
char *src = func(myUnion);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13525 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
unionType myUnion;
myUnion.unionFirst = part;
AnimationFrame &frame = func(myUnion);
AnimationFrame func(unionType &myUnion)
AnimationPart &part = myUnion.unionSecond;
return part.frames.back();
AnimationFrame &frame = func(myUnion);
strcpy(frame.path, name.c_str());
0

13539 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
unionType myUnion;
myUnion.unionFirst = parts;
AnimationPart &part = func(myUnion, i);
AnimationPart func(unionType &myUnion, uint32_t i)
parts = myUnion.unionSecond;
return parts[i];
AnimationPart &part = func(myUnion, i);
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

13540 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
unionType myUnion;
myUnion.unionFirst = k;
AnimationFrame &frame = func(part, myUnion);
AnimationFrame func(AnimationPart& part, unionType myUnion)
uint32_t k = myUnion.unionSecond;
return part.frames[k];
AnimationFrame &frame = func(part, myUnion);
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13541 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
unionType myUnion;
myUnion.unionFirst = k;
AnimationFrame &frame = func(part, myUnion);
AnimationFrame func(AnimationPart& part, unionType myUnion)
uint32_t k = myUnion.unionSecond;
return part.frames[k];
AnimationFrame &frame = func(part, myUnion);
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13542 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
unionType myUnion;
myUnion.unionFirst = frame;
char *src = func(myUnion);
char* func(unionType &myUnion)
AnimationFrame &frame = myUnion.unionSecond;
return frame.buf;
char *src = func(myUnion);
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13543 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
unionType myUnion;
myUnion.unionFirst = part;
AnimationFrame &frame = func(myUnion);
AnimationFrame func(unionType &myUnion)
AnimationPart &part = myUnion.unionSecond;
return part.frames.back();
AnimationFrame &frame = func(myUnion);
strcpy(frame.path, name.c_str());
1

13561 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
const char *line = descCopy.c_str();
int32_t width, height, fps;
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
entry = nullptr;
AnimationPart &part = parts[i];
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13562 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
AnimationPart part;
end = strstr(line, "\n");
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13563 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13564 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int starty = (buf->height - frame.height) / 2;
int startx = (buf->width - frame.width) / 2;
int dst_stride = buf->stride * frame.bytepp;
int src_stride = frame.width * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13565 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
AnimationPart part;
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
0

13566 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
AnimationPart part;
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
0

13583 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
const char *line = descCopy.c_str();
int32_t width, height, fps;
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
char search[256];
entry = nullptr;
AnimationPart &part = parts[i];
snprintf(search, sizeof(search), "%s/", part.path);
1

13584 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
AnimationPart part;
end = strstr(line, "\n");
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

13585 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

13586 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int starty = (buf->height - frame.height) / 2;
int startx = (buf->width - frame.width) / 2;
int dst_stride = buf->stride * frame.bytepp;
int src_stride = frame.width * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

13587 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
AnimationPart part;
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
1

13588 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
AnimationPart part;
const char *line = descCopy.c_str();
end = strstr(line, "\n");
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
1

13977 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
0

13978 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());}
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
0

13979 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
0

13980 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (part.ReadFromString(line)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
0

13981 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
0

13982 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (part.ReadFromString(line)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
0

14015 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_LowBound 533
static void * AnimationThread(void *)
int32_t width, height, fps;
const char *line = descCopy.c_str();
const char *end;
bool headerRead = true;
vector<AnimationPart> parts;
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
1

14016 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 585
static void * AnimationThread(void *)
do {
end = strstr(line, "\n");
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
parts.push_back(part);   }
} while (end && *(line = end + 1));
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
entry = nullptr;
char search[256];
snprintf(search, sizeof(search), "%s/", part.path);
while ((entry = reader.GetNextEntry(entry))) {
string name = reader.GetEntryName(entry);
if (name.find(search) ||
!entry->GetDataSize() ||
name.length() >= 256)
continue;
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
frame.file = reader.GetLocalEntry(entry);
sort(part.frames.begin(), part.frames.end());
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
AnimationFrame &frame = part.frames[k];
ANativeWindowBuffer *buf = display->DequeueBuffer();
wchar_t bgfill = AsBackgroundFill(frame.bgcolor, format);
wmemset((wchar_t*)vaddr, bgfill, (buf->height * buf->stride * frame.bytepp) / sizeof(wchar_t));
1

14017 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 590
static void * AnimationThread(void *)
vector<AnimationPart> parts;
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);        }
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
AnimationFrame &frame = part.frames[k];
if (!frame.buf) {
frame.ReadPngFrame(format);             }
void *vaddr;
if (grmodule->lock(grmodule, buf->handle,
GRALLOC_USAGE_SW_READ_NEVER |
GRALLOC_USAGE_SW_WRITE_OFTEN |
GRALLOC_USAGE_HW_FB,
0, 0, width, height, &vaddr)) {
LOGW("Failed to lock buffer_handle_t");
display->QueueBuffer(buf);
break;                }
if (buf->height == frame.height && buf->stride == frame.width) {
memcpy(vaddr, frame.buf,  frame.width * frame.height * frame.bytepp);
1

14018 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_boundedcpy 603
static void * AnimationThread(void *)
AnimationPart part;
if (headerRead &&
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
headerRead = false;
} else if (sscanf(line, "p %d %d %s",
&part.count, &part.pause, part.path)) {
parts.push_back(part);
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
uint32_t j = 0;
while (sRunAnimation && (!part.count || j++ < part.count)) {
for (uint32_t k = 0; k < part.frames.size(); k++) {
struct timeval tv1, tv2;
gettimeofday(&tv1, nullptr);
AnimationFrame &frame = part.frames[k];
int startx = (buf->width - frame.width) / 2;
int starty = (buf->height - frame.height) / 2;
int src_stride = frame.width * frame.bytepp;
int dst_stride = buf->stride * frame.bytepp;
char *src = frame.buf;
char *dst = (char *) vaddr + starty * dst_stride + startx * frame.bytepp;
for (int i = 0; i < frame.height; i++) {
memcpy(dst, src, src_stride);
1

14019 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Format_String_Attack 523
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
1

14020 CVE-2015-7176/Firefox_40.0b9_CVE_2015_7176_widget_gonk_libdisplay_BootAnimation.cpp Buffer_Overflow_cpycat 543
static void *AnimationThread(void *)
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
bool OpenArchive(const char *path)
fd = open(path, O_RDONLY);
if (fstat(fd, &sb) == -1 || sb.st_size < sizeof(cdir_end)) {
mBuf = (char *)mmap(nullptr, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
if (!reader.OpenArchive("/system/media/bootanimation.zip")) {
int32_t width, height, fps;
while ((entry = reader.GetNextEntry(entry))) {
entry = (cdir_entry *)(mBuf + letoh32(mEnd->cdir_offset));
!entry->Valid())
if (((char *)entry + entry->GetSize()) > mCdir_limit ||
return entry;
while ((entry = reader.GetNextEntry(entry))) {
descCopy.append(file->GetData(), entry->GetDataSize());
return letoh32(compressed_size);
descCopy.append(file->GetData(), entry->GetDataSize());
const char *line = descCopy.c_str();
end = strstr(line, "\n");
AnimationPart part;
sscanf(line, "%d %d %d", &width, &height, &fps) == 3) {
} else if (sscanf(line, "p %d %d %s", &part.count, &part.pause, part.path)) {
for (uint32_t i = 0; i < parts.size(); i++) {
AnimationPart &part = parts[i];
part.frames.push_back();
AnimationFrame &frame = part.frames.back();
strcpy(frame.path, name.c_str());
1

