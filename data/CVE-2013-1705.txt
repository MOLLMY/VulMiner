14278 CVE-2013-1705/Firefox_18.0_CVE_2013_1705_security_manager_ssl_src_nsCrypto.cpp String_Termination_Error 378
JSAutoByteString params, keyGenAlg;
keyGenAlg.encode(cx, jsString);
NS_ENSURE_TRUE(!!keyGenAlg, NS_ERROR_OUT_OF_MEMORY);
keyGenType->keyGenType = cryptojs_interpret_key_gen_type(keyGenAlg.ptr());
static nsKeyGenType cryptojs_interpret_key_gen_type(char *keyAlg)
char *end;
if (keyAlg == nullptr)
return invalidKeyGen;
while (isspace(keyAlg[0])) keyAlg++;
end = strchr(keyAlg, '\0');
if (end == nullptr)
return invalidKeyGen;
end--;
while (isspace(*end)) end--;
end[1] = '\0';
if (strcmp(keyAlg, "rsa-ex") == 0) {
return rsaEnc;
} else if (strcmp(keyAlg, "rsa-dual-use") == 0) {
return rsaDualUse;
} else if (strcmp(keyAlg, "rsa-sign") == 0) {
return rsaSign;
} else if (strcmp(keyAlg, "rsa-sign-nonrepudiation") == 0) {
return rsaSignNonrepudiation;
} else if (strcmp(keyAlg, "rsa-nonrepudiation") == 0) {
return rsaNonrepudiation;
} else if (strcmp(keyAlg, "ec-ex") == 0) {
return ecEnc;
} else if (strcmp(keyAlg, "ec-dual-use") == 0) {
return ecDualUse;
} else if (strcmp(keyAlg, "ec-sign") == 0) {
return ecSign;
} else if (strcmp(keyAlg, "ec-sign-nonrepudiation") == 0) {
return ecSignNonrepudiation;
} else if (strcmp(keyAlg, "ec-nonrepudiation") == 0) {
return ecNonrepudiation;
} else if (strcmp(keyAlg, "dsa-sign-nonrepudiation") == 0) {
return dsaSignNonrepudiation;
} else if (strcmp(keyAlg, "dsa-sign") ==0 ){
return dsaSign;
} else if (strcmp(keyAlg, "dsa-nonrepudiation") == 0) {
return dsaNonrepudiation;
} else if (strcmp(keyAlg, "dh-ex") == 0) {
return dhEx;
return invalidKeyGen;
if (keyGenType->keyGenType == invalidKeyGen)
JS_ReportError(cx, "%s%s%s", JS_ERROR,
"invalid key generation argument:",
keyGenAlg.ptr());
goto loser;
if (*slot == nullptr)
*slot = nsGetSlotForKeyGen(keyGenType->keyGenType, uiCxt);
if (*slot == nullptr)
goto loser;
rv = cryptojs_generateOneKeyPair(cx,keyGenType,keySize,params.ptr(),uiCxt, *slot,willEscrow);
if (rv != NS_OK)
JS_ReportError(cx,"%s%s%s", JS_ERROR,
"could not generate the key for algorithm ",
keyGenAlg.ptr());
goto loser;
return NS_OK;
loser:
return NS_ERROR_FAILURE;
1

14279 CVE-2013-1705/Firefox_18.0_CVE_2013_1705_security_manager_ssl_src_nsCrypto.cpp String_Termination_Error 378
JSAutoByteString params;
nsDependentJSString dependentKeyGenAlg;
NS_ENSURE_TRUE(dependentKeyGenAlg.init(cx, jsString), NS_ERROR_UNEXPECTED);
nsAutoString keyGenAlg(dependentKeyGenAlg);
keyGenAlg.Trim("\r\n\t ");
keyGenType->keyGenType = cryptojs_interpret_key_gen_type(keyGenAlg);
static nsKeyGenType cryptojs_interpret_key_gen_type(char *keyAlg)
if (keyAlg.EqualsLiteral("rsa-ex"))
return rsaEnc;
if (keyAlg.EqualsLiteral("rsa-dual-use"))
return rsaDualUse;
return rsaSign;
if (keyAlg.EqualsLiteral("rsa-sign-nonrepudiation"))
return rsaSignNonrepudiation;
if (keyAlg.EqualsLiteral("rsa-nonrepudiation"))
return rsaNonrepudiation;
if (keyAlg.EqualsLiteral("ec-ex")) {
return ecEnc;
if (keyAlg.EqualsLiteral("ec-dual-use")) {
return ecDualUse;
if (keyAlg.EqualsLiteral("ec-sign"))
return ecSign;
if (keyAlg.EqualsLiteral("ec-sign-nonrepudiation"))
return ecSignNonrepudiation;
if (keyAlg.EqualsLiteral("ec-nonrepudiation"))
return ecNonrepudiation;
if (keyAlg.EqualsLiteral("dsa-sign-nonrepudiation"))
return dsaSignNonrepudiation;
if (keyAlg.EqualsLiteral("dsa-sign"))
return dsaSign;
if (keyAlg.EqualsLiteral("dsa-nonrepudiation"))
return dsaNonrepudiation;
if (keyAlg.EqualsLiteral("dh-ex"))
return dhEx;
return invalidKeyGen;
if (keyGenType->keyGenType == invalidKeyGen)
NS_LossyConvertUTF16toASCII keyGenAlgNarrow(dependentKeyGenAlg);
JS_ReportError(cx, "%s%s%s", JS_ERROR,
"invalid key generation argument:",
keyGenAlgNarrow.get());
goto loser;
if (*slot == nullptr)
*slot = nsGetSlotForKeyGen(keyGenType->keyGenType, uiCxt);
if (*slot == nullptr)
goto loser;
rv = cryptojs_generateOneKeyPair(cx,keyGenType,keySize,params.ptr(),uiCxt, *slot,willEscrow);
if (rv != NS_OK)
NS_LossyConvertUTF16toASCII keyGenAlgNarrow(dependentKeyGenAlg);
JS_ReportError(cx,"%s%s%s", JS_ERROR,
"could not generate the key for algorithm ",
keyGenAlgNarrow.get());
goto loser;
return NS_OK;
loser:
return NS_ERROR_FAILURE;
0

