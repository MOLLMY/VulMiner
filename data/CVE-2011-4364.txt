134 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 488
void *data, int *data_size,
const uint8_t *buf, int buf_size)
unsigned char *output_samples = (unsigned char *)data;
const unsigned char *p = buf + 16;
*data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);
uint32_t flags = AV_RB32(p);
int raw_block_size = s->block_align * s->bits / 8;
silent_chunks = 32;
silent_chunks = av_log2(flags + 1);
memset(output_samples, 0, raw_block_size * silent_chunks);
output_samples += raw_block_size * silent_chunks;
*data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);
*data_size = vmdaudio_loadsound(s, output_samples, p, 1, 0);
const uint8_t *buf, int silence, int data_size)
memset(data, 0, data_size * 2);
static int vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,
memset(data, 0, data_size * 2);
0

176 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 505
void *data, int *data_size,
const uint8_t *buf, int buf_size)
unsigned char *output_samples = (unsigned char *)data;
const unsigned char *p = buf + 16;
*data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);
uint32_t flags = AV_RB32(p);
int raw_block_size = s->block_align * s->bits / 8;
silent_chunks = 32;
silent_chunks = av_log2(flags + 1);
memset(output_samples, 0, raw_block_size * silent_chunks);
output_samples += raw_block_size * silent_chunks;
*data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);
*data_size = vmdaudio_loadsound(s, output_samples, p, 1, 0);
const uint8_t *buf, int silence, int data_size)
memset(data, 0, data_size * 2);
static int vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,
memset(data, 0, data_size * 2);
0

236 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 550
void *data, int *data_size,
unsigned char *output_samples = (unsigned char *)data;
memset(output_samples, 0, raw_block_size * silent_chunks);
0

371 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 388
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void vmd_decode(VmdVideoContext *s)
frame_x = AV_RL16(&s->buf[6]);
s->x_off = frame_x;
static void vmd_decode(VmdVideoContext *s)
vmd_decode(s);
memcpy(s->frame.data[1], s->palette, PALETTE_COUNT * 4);
0

602 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 310
ps = src;
*pd++ = *ps++;
l = *ps++;
l = (l & 0x7F) * 2;
return ps - src;
memcpy(pd, ps, l);
ps += l;
return ps - src;
ps += 2;
return ps - src;
return ps - src;
return ps - src;
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
p += 2;
r = *p++ * 4;
g = *p++ * 4;
b = *p++ * 4;
pb = p;
meth = *pb++;
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x];
pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];
len = *pb++;
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
memcpy(&dp[ofs], pb, len);
len = *pb++;
pb += len;
len = *pb++;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
memcpy(&dp[ofs], pb, len);
pb += len;
if (*pb++ == 0xFF)
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
dp += s->frame.linesize[0];
memcpy(&dp[ofs], &pp[ofs], len + 1);
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
pb = s->unpack_buffer;
len = *pb++;
if (*pb++ == 0xFF)
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
static int rle_unpack(const unsigned char *src, unsigned char *dest,
len = *pb++;
if (*pb++ == 0xFF)
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
static void vmd_decode(VmdVideoContext *s)
const unsigned char *p = s->buf + 16;
pb = p;
len = *pb++;
if (*pb++ == 0xFF)
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

605 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 263
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
p += 2;
r = *p++ * 4;
g = *p++ * 4;
b = *p++ * 4;
pb = p;
meth = *pb++;
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x];
pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
memcpy(&dp[ofs], pb, len);
dp += s->frame.linesize[0];
memcpy(&dp[ofs], pb, len);
pp += s->prev_frame.linesize[0];
memcpy(&dp[ofs], &pp[ofs], len + 1);
memcpy(&dp[ofs], pb, len);
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void vmd_decode(VmdVideoContext *s)
const unsigned char *p = s->buf + 16;
pb = p;
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
pb = s->unpack_buffer;
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
1

655 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 286
frame_x = AV_RL16(&s->buf[6]);
frame_y = AV_RL16(&s->buf[8]);
frame_width = AV_RL16(&s->buf[10]) - frame_x + 1;
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
p += 2;
r = *p++ * 4;
g = *p++ * 4;
b = *p++ * 4;
pb = p;
meth = *pb++;
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x];
memcpy(dp, pb, frame_width);
pb += frame_width;
memcpy(dp, pb, frame_width);
dp += s->frame.linesize[0];
memcpy(dp, pb, frame_width);
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
pb = s->unpack_buffer;
memcpy(dp, pb, frame_width);
static void vmd_decode(VmdVideoContext *s)
const unsigned char *p = s->buf + 16;
frame_width = AV_RL16(&s->buf[10]) - frame_x + 1;
pb = p;
memcpy(dp, pb, frame_width);
1

659 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 303
ps += l;
return ps - src;
return ps - src;
ps += 2;
return ps - src;
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
p += 2;
r = *p++ * 4;
g = *p++ * 4;
b = *p++ * 4;
pb = p;
meth = *pb++;
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x];
pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];
len = *pb++;
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
memcpy(&dp[ofs], pb, len);
pb += len;
len = *pb++;
len = (len & 0x7F) + 1;
pp += s->prev_frame.linesize[0];
memcpy(&dp[ofs], &pp[ofs], len + 1);
dp += s->frame.linesize[0];
memcpy(&dp[ofs], pb, len);
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void vmd_decode(VmdVideoContext *s)
const unsigned char *p = s->buf + 16;
pb = p;
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
pb = s->unpack_buffer;
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
1

668 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c cfunc 270
memcpy(s->frame.data[0], s->prev_frame.data[0],
s->avctx->height * s->frame.linesize[0]);
p += 2;
r = *p++ * 4;
g = *p++ * 4;
b = *p++ * 4;
pb = p;
meth = *pb++;
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x];
pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];
len = *pb++;
len = (len & 0x7F) + 1;
memcpy(&dp[ofs], pb, len);
pb += len;
len = *pb++;
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
dp += s->frame.linesize[0];
memcpy(&dp[ofs], &pp[ofs], len + 1);
VmdVideoContext *s = avctx->priv_data;
vmd_decode(s);
static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)
pb = s->unpack_buffer;
len = *pb++;
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
static void vmd_decode(VmdVideoContext *s)
const unsigned char *p = s->buf + 16;
pb = p;
len = *pb++;
memcpy(&dp[ofs], pb, len);
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13036 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13037 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13638 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = func(sep);
static char * func(const char * pb)
pb = s->unpack_buffer;
return pb;
pb = func(pb);
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13639 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = func(sep);
static char * func(const char * pb)
pb = s->unpack_buffer;
return pb;
pb = func(pb);
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13640 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = func(&pb);
static char * func(char * * ptr)
char * pb = *ptr;
pb = s->unpack_buffer;
return pb;
pb = func(&pb);
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13641 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = func(&pb);
static char * func(char * * ptr)
char * pb = *ptr;
pb = s->unpack_buffer;
return pb;
pb = func(&pb);
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13642 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
void (*funcPtr) (char *) = badSource;
funcPtr(pb)
void badSource(char * pb)
pb = s->unpack_buffer;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13643 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
void (*funcPtr) (char *) = badSource;
funcPtr(pb)
void badSource(char * pb)
pb = s->unpack_buffer;
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13644 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
char * dataCopy = pb;
char * pb = dataCopy;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13645 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
char * dataCopy = pb;
char * pb = dataCopy;
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13646 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
component_len = ofs + len;
if (component_len> frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (component_len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (component_len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13647 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
component_len = ofs + len;
if (component_len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (component_len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (component_len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13648 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
switch (meth)
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13649 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
pb_size = s->unpack_buffer_size;
switch (meth)
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13650 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
char * dataArray[5];
dataArray[2] = pb;
pb = badSource(dataArray);
void badSource(char * dataArray[])
char * pb = dataArray[2];
pb = s->unpack_buffer;
return pb
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13651 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
char * dataArray[5];
dataArray[2] = pb;
pb = badSource(dataArray);
void badSource(char * dataArray[])
char * pb = dataArray[2];
pb = s->unpack_buffer;
return pb
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13652 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
unionType myUnion;
myUnion.unionFirst = pb;
char * pb = myUnion.unionSecond;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13653 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
pb = s->unpack_buffer;
unionType myUnion;
myUnion.unionFirst = pb;
char * pb = myUnion.unionSecond;
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

13654 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size >= 0)
pb = p;
meth = *pb++;
if (meth & 0x80)
lz_unpack(pb, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
structType myStruct;
myStruct.structFirst = pb;
pb = badSource(myStruct);
void badSource(structType myStruct)
char * pb = myStruct.structFirst;
pb = s->unpack_buffer;
return pb
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
memcpy(dp, pb, frame_width);
pb += frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, frame_width - ofs);
else
memcpy(&dp[ofs], pb, len);
pb += len;
ofs += len;
else
if (ofs + len + 1 > frame_width)
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
1

13655 CVE-2011-4364/Ffmpeg_0.5.4_CVE_2011_4364_libavcodec_vmdav.c Buffer_Overflow_boundedcpy 167
const unsigned char *p = s->buf + 16;
const unsigned char *pb;
if (frame_x || frame_y || (frame_width != s->avctx->width) || (frame_height != s->avctx->height))
memcpy(s->frame.data[0], s->prev_frame.data[0],s->avctx->height * s->frame.linesize[0]);
if (s->size > 0)
pb = p;
pb_size = s->buf + s->size - pb;
if (pb_size < 1)
return;
meth = *pb++; pb_size--;
if (meth & 0x80)
lz_unpack(pb, pb_size, s->unpack_buffer, s->unpack_buffer_size);
meth &= 0x7F;
structType myStruct;
myStruct.structFirst = pb;
pb = badSource(myStruct);
void badSource(structType myStruct)
char * pb = myStruct.structFirst;
pb = s->unpack_buffer;
return pb
pb_size = s->unpack_buffer_size;
switch (meth)
case 1:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (ofs + len > frame_width || pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= len;
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
case 2:
for (i = 0; i < frame_height; i++)
if (pb_size < frame_width)
return;
memcpy(dp, pb, frame_width);
pb += frame_width;
pb_size -= frame_width;
case 3:
for (i = 0; i < frame_height; i++)
do
if (pb_size < 1)
return;
len = *pb++;
pb_size--;
if (len & 0x80)
len = (len & 0x7F) + 1;
if (pb_size < 1)
return;
if (*pb++ == 0xFF)
len = rle_unpack(pb, &dp[ofs], len, pb_size, frame_width - ofs);
else
if (pb_size < len)
return;
memcpy(&dp[ofs], pb, len);
pb += len;
pb_size -= 1 + len;
ofs += len;
else
if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])
return;
memcpy(&dp[ofs], &pp[ofs], len + 1);
0

