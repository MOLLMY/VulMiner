62 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c cfunc 100
static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,
const uint8_t *buf = avpkt->data;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {
samples     = s->frame.data[0];
memcpy(samples, buf, out_size);
0

670 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c cfunc 166
static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {
samples     = s->frame.data[0];
count = *buf & 0x3F;
case 0:  smp = 4;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
code = *buf++;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ((code >> 2) & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ((code >> 4) & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample +=  (code >> 6)        - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
code = *buf++;
count = *buf & 0x3F;
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
code = *buf++;
sample += ( code       & 0x3) - 2;
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ws_adpcm_4bit[code & 0xF];
sample = av_clip_uint8(sample);
*samples++ = sample;
sample += ws_adpcm_4bit[code >> 4];
sample = av_clip_uint8(sample);
*samples++ = sample;
t = count;
t <<= 3;
sample += t >> 3;
sample = av_clip_uint8(sample);
*samples++ = sample;
memcpy(samples, buf, smp);
samples += smp;
memcpy(samples, buf, smp);
buf     += smp;
memcpy(samples, buf, smp);
sample = buf[-1];
sample = av_clip_uint8(sample);
*samples++ = sample;
memcpy(samples, buf, smp);
memset(samples, sample, smp);
samples += smp;
memcpy(samples, buf, smp);
1

13038 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13039 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13656 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples = func(samples);
static char * func(const char * samples)
samples     = s->frame.data[0];
return samples;
samples = func(samples);
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13657 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples = func(samples);
static char * func(const char * samples)
samples     = s->frame.data[0];
return samples;
samples = func(samples);
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13658 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples = func(&samples);
static char * func(char * * ptr)
char * samples = *ptr;
samples     = s->frame.data[0];
return samples;
samples = func(&samples);
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13659 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples = func(&samples);
static char * func(char * * ptr)
char * samples = *ptr;
samples     = s->frame.data[0];
return samples;
samples = func(&samples);
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13660 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
void (*funcPtr) (char *) = badSource;
funcPtr(samples)
void badSource(char * samples)
samples     = s->frame.data[0];
samples = func(&samples);
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13661 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
void (*funcPtr) (char *) = badSource;
funcPtr(samples)
void badSource(char * samples)
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13662 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
void (*funcPtr) (char *) = badSource;
funcPtr(samples)
void badSource(char * samples)
samples     = s->frame.data[0];
char * dataCopy = samples;
char * samples = dataCopy;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13663 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples     = s->frame.data[0];
char * dataCopy = samples;
char * samples = dataCopy;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13664 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (*buf & 0x3F & 0x20) ? 1 : *buf & 0x3F + 1; break;
default: smp = *buf & 0x3F + 1;                      break;
default:
memset(samples, sample, smp);
1

13665 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
switch (code)
case 0:  smp = 4*(*buf & 0x3F+1);                    break;
case 1:  smp = 2*(*buf & 0x3F+1);                    break;
case 2:  smp = (*buf & 0x3F & 0x20) ? 1 : *buf & 0x3F + 1; break;
default: smp = *buf & 0x3F + 1;                      break;
default:
memset(samples, sample, smp);
0

13666 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
samples     = s->frame.data[0];
samples_end = samples + out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13667 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
samples     = s->frame.data[0];
samples_end = samples + out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13668 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
char * dataArray[5];
dataArray[2] = samples;
samples = badSource(dataArray);
void badSource(char * dataArray[])
char * samples = dataArray[2];
samples     = s->frame.data[0];
return samples;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13669 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
char * dataArray[5];
dataArray[2] = samples;
samples = badSource(dataArray);
void badSource(char * dataArray[])
char * samples = dataArray[2];
samples     = s->frame.data[0];
return samples;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13670 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
unionType myUnion;
myUnion.unionFirst = samples;
char * samples = myUnion.unionSecond;
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13671 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
unionType myUnion;
myUnion.unionFirst = samples;
char * samples = myUnion.unionSecond;
samples     = s->frame.data[0];
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

13672 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
structType myStruct;
myStruct.structFirst = samples;
samples = badSource(myStruct);
void badSource(structType myStruct)
char * samples = myStruct.structFirst;
samples     = s->frame.data[0];
return samples;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4;                              break;
case 1:  smp = 2;                              break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
1

13673 CVE-2012-0848/Ffmpeg_0.9_CVE_2012_0848_libavcodec_ws-snd1.c Buffer_Overflow_boundedcpy 173
const uint8_t *buf = avpkt->data;
int sample = 128;
out_size = AV_RL16(&buf[0]);
in_size  = AV_RL16(&buf[2]);
buf += 4;
s->frame.nb_samples = out_size;
if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0)
av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
structType myStruct;
myStruct.structFirst = samples;
samples = badSource(myStruct);
void badSource(structType myStruct)
char * samples = myStruct.structFirst;
samples     = s->frame.data[0];
return samples;
samples_end = samples + out_size;
while (samples < samples_end && buf - avpkt->data < buf_size)
code  = *buf >> 6;
count = *buf & 0x3F;
switch (code)
case 0:  smp = 4*(count+1);                    break;
case 1:  smp = 2*(count+1);                    break;
case 2:  smp = (count & 0x20) ? 1 : count + 1; break;
default: smp = count + 1;                      break;
default:
memset(samples, sample, smp);
0

