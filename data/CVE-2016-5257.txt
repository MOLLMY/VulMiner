97 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 377
uint8_t* frame_buffer,
size_t frame_buffer_length,
memset(fragmentation->fragmentationLength, 0,
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
fragmentation->fragmentationOffset[0] = 0;
for (int i = 1; i < fragmentation->fragmentationVectorSize; ++i) {
fragmentation->fragmentationOffset[i - 1] +
fragmentation->fragmentationLength[i - 1];
fragmentation->fragmentationOffset[i] =
fragmentation->fragmentationOffset[i - 1]);
fragmentation->fragmentationOffset[i] >=
assert(i == 0 ||
0

98 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 377
uint8_t* frame_buffer,
size_t frame_buffer_length,
memset(fragmentation->fragmentationLength, 0,
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
fragmentation->fragmentationOffset[0] = 0;
for (int i = 1; i < fragmentation->fragmentationVectorSize; ++i) {
fragmentation->fragmentationOffset[i - 1] +
fragmentation->fragmentationLength[i - 1];
fragmentation->fragmentationOffset[i] =
fragmentation->fragmentationOffset[i - 1]);
fragmentation->fragmentationOffset[i] >=
assert(i == 0 ||
0

335 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cfunc 250
SetState(kStateIncomplete);
_state == kStateIncomplete);
assert(_state == kStateEmpty ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty ||
0

336 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cppfunc 250
SetState(kStateIncomplete);
_state == kStateIncomplete);
assert(_state == kStateEmpty ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty ||
0

365 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 223
const size_t kH264NALHeaderLengthInBytes = 1;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
frame_buffer_ptr += Insert(nalu_ptr,
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
first_packet_seq_num_ = static_cast<int>(packet.seqNum);
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
buffer,
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
frame_buffer_ptr += Insert(nalu_ptr,
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
packet.sizeBytes = Insert(packet_buffer,
0

366 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 222
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,
packet.dataPtr = frame_buffer + offset;
const size_t kH264NALHeaderLengthInBytes = 1;
const size_t kLengthFieldLength = 2;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
nalu_ptr += kLengthFieldLength;
frame_buffer_ptr += Insert(nalu_ptr,
length,
const_cast<uint8_t*>(packet.dataPtr));
size_t length,
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
uint8_t* frame_buffer,
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
VCMPacket& packet = *packet_it;
size_t offset = 0;
offset += (*it).sizeBytes;
const uint8_t* packet_buffer = packet.dataPtr;
packet.dataPtr = frame_buffer + offset;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
uint8_t* frame_buffer_ptr = frame_buffer + offset;
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
buffer,
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer + (insert_start_code ? kH264StartCodeLengthBytes : 0),
0

367 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 220
const size_t kLengthFieldLength = 2;
nalu_ptr += kLengthFieldLength;
frame_buffer_ptr += Insert(nalu_ptr,
const unsigned char startCode[] = {0, 0, 0, 1};
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
uint8_t* frame_buffer,
if (packets_.size() == kMaxPacketsInSession) {
ReversePacketIterator rit = packets_.rbegin();
for (; rit != packets_.rend(); ++rit)
if (rit != packets_.rend() &&
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum))) {
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_))) {
first_packet_seq_num_ = static_cast<int>(packet.seqNum);
IsNewerSequenceNumber(first_packet_seq_num_, packet.seqNum)) {
last_packet_seq_num_ = static_cast<int>(packet.seqNum);
IsNewerSequenceNumber(packet.seqNum, last_packet_seq_num_)) {
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
size_t offset = 0;
offset += (*it).sizeBytes;
const uint8_t* packet_buffer = packet.dataPtr;
packet.dataPtr = frame_buffer + offset;
const size_t kH264NALHeaderLengthInBytes = 1;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
uint8_t* frame_buffer_ptr = frame_buffer + offset;
nalu_ptr += length;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,
packet.dataPtr = frame_buffer + offset;
const_cast<uint8_t*>(packet.dataPtr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
int VCMSessionInfo::InsertPacket(const VCMPacket& packet,
PacketIterator packet_list_it = packets_.insert(rit.base(), packet);
size_t returnLength = InsertBuffer(frame_buffer, packet_list_it);
PacketIterator packet_it) {
VCMPacket& packet = *packet_it;
const uint8_t* packet_buffer = packet.dataPtr;
nalu_ptr = packet_buffer + kH264NALHeaderLengthInBytes;
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
size_t VCMSessionInfo::Insert(const uint8_t* buffer,
buffer,
size_t length = BufferToUWord16(nalu_ptr);
length,
size_t length,
length);
return length;
frame_buffer_ptr += Insert(nalu_ptr,
const_cast<uint8_t*>(frame_buffer_ptr));
uint8_t* frame_buffer) {
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
0

379 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 381
uint8_t* frame_buffer,
size_t frame_buffer_length,
size_t new_length = 0;
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
new_length += fragmentation->fragmentationLength[partition_id];
assert(new_length <= frame_buffer_length);
0

380 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 381
uint8_t* frame_buffer,
size_t frame_buffer_length,
size_t new_length = 0;
(*it).dataPtr - frame_buffer;
fragmentation->fragmentationOffset[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
new_length += fragmentation->fragmentationLength[partition_id];
assert(new_length <= frame_buffer_length);
0

419 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 356
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
assert(fragmentation->fragmentationLength[partition_id] <=
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
0

420 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 356
(*partition_end).dataPtr + (*partition_end).sizeBytes - (*it).dataPtr;
fragmentation->fragmentationLength[partition_id] =
assert(fragmentation->fragmentationLength[partition_id] <=
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
0

421 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 224
size_t length = BufferToUWord16(nalu_ptr);
memcpy(frame_buffer, startCode, kH264StartCodeLengthBytes);
length += (insert_start_code ? kH264StartCodeLengthBytes : 0);
nalu_ptr += length;
length,
packet.sizeBytes +
(packet.insertStartCode ? kH264StartCodeLengthBytes : 0));
int steps_to_shift) {
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
packet.sizeBytes,
size_t length,
length);
0

533 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cfunc 232
SetState(kStateIncomplete);
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty);
0

534 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cppfunc 232
SetState(kStateIncomplete);
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
assert(_state == kStateEmpty);
0

537 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cfunc 239
SetState(kStateIncomplete);
_state == kStateIncomplete ||
assert(_state == kStateEmpty ||
_state == kStateIncomplete ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
_state == kStateDecodable);
_state == kStateIncomplete ||
0

538 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc cppfunc 239
SetState(kStateIncomplete);
_state == kStateIncomplete ||
assert(_state == kStateEmpty ||
_state == kStateIncomplete ||
VCMFrameBuffer::SetState(VCMFrameBufferStateEnum state) {
_state = state;
SetState(kStateIncomplete);
SetState(kStateDecodable);
_state == kStateDecodable);
_state == kStateIncomplete ||
0

539 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cfunc 360
size_t frame_buffer_length,
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
0

540 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc cppfunc 360
size_t frame_buffer_length,
frame_buffer_length);
assert(fragmentation->fragmentationOffset[partition_id] <
frame_buffer_length);
assert(fragmentation->fragmentationLength[partition_id] <=
0

13105 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13143 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13180 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
component_data = shift_length;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, component_data);
0

13217 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
component_data = shift_length;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13236 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += func(it);
int func(PacketIterator &it)
return (*it).sizeBytes;
shift_length += func(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13255 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += func(it);
int func(PacketIterator &it)
return (*it).sizeBytes;
shift_length += func(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13274 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
PacketIterator dataArray[5];
dataArray[2] = it;
shift_length += goodSource(dataArray);
int goodSource(PacketIterator dataArray[])
PacketIterator it = dataArray[2];
return (*it).sizeBytes;
shift_length += goodSource(dataArray);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13292 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
PacketIterator dataArray[5];
dataArray[2] = it;
shift_length += badSource(dataArray);
int badSource(PacketIterator dataArray[])
PacketIterator it = dataArray[2];
return (*it).sizeBytes;
shift_length += badSource(dataArray);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13317 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
int (*funcPtr)(PacketIterator ) = goodSource;
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += funcPtr(it);
int goodSource(PacketIterator it)
return (*it).sizeBytes;
shift_length += funcPtr(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13343 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
int (*funcPtr)(PacketIterator ) = badSource;
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += funcPtr(it);
int badSource(PacketIterator it)
return (*it).sizeBytes;
shift_length += funcPtr(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13369 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += func(it);
int func(PacketIterator it)
return (*it).sizeBytes;
shift_length += func(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13395 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += func(it);
int func(PacketIterator it)
return (*it).sizeBytes;
shift_length += func(it);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13433 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
uint8_t* dataType = first_packet_ptr;
first_packet_ptr = dataType;
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13471 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
uint8_t* dataType = first_packet_ptr;
first_packet_ptr = dataType;
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13490 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
structType myStruct;
myStruct.structFirst = it;
shift_length += func(myStruct);
int func(structType &myStruct)
PacketIterator it = myStruct.structFirst;
return (*it).sizeBytes;
shift_length += func(myStruct);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13508 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
structType myStruct;
myStruct.structFirst = it;
shift_length += func(myStruct);
int func(structType &myStruct)
PacketIterator it = myStruct.structFirst;
return (*it).sizeBytes;
shift_length += func(myStruct);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13526 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
unionType myUnion;
myUnion.unionFirst = it;
shift_length += func(myUnion);
int func(unionType &myUnion)
PacketIterator it = myUnion.unionSecond;
return (*it).sizeBytes;
shift_length += func(myUnion);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13544 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length +=
length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
unionType myUnion;
myUnion.unionFirst = it;
shift_length += func(myUnion);
int func(unionType &myUnion)
PacketIterator it = myUnion.unionSecond;
return (*it).sizeBytes;
shift_length += func(myUnion);
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13567 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
int shift_length = 0;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

13589 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
int shift_length = 0;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

13983 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr + kLengthFieldLength <= packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
if (nalu_ptr + kLengthFieldLength + length <= packet_buffer + packet.sizeBytes) {
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
nalu_ptr += kLengthFieldLength + length;
} else {
LOG(LS_ERROR) << "Failed to insert packet due to corrupt H264 STAP-A";
return 0;    }   }
if (required_length > packet.sizeBytes + kBufferSafetyMargin) {
LOG(LS_ERROR) << "Failed to insert packet due to too many NALs in a STAP-A";
return 0;}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;}
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
0

14021 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_session_info.cc Buffer_Overflow_boundedcpy 243
size_t VCMSessionInfo::InsertBuffer(uint8_t* frame_buffer,acketIterator packet_it) {
size_t required_length = 0;
while (nalu_ptr < packet_buffer + packet.sizeBytes) {
size_t length = BufferToUWord16(nalu_ptr);
required_length += length + (packet.insertStartCode ? kH264StartCodeLengthBytes : 0);}
ShiftSubsequentPackets(packet_it, required_length);
void VCMSessionInfo::ShiftSubsequentPackets(PacketIterator it,  int steps_to_shift) {
++it;
if (it == packets_.end())
return;
uint8_t* first_packet_ptr = const_cast<uint8_t*>((*it).dataPtr);
int shift_length = 0;
for (; it != packets_.end(); ++it) {
shift_length += (*it).sizeBytes;
if ((*it).dataPtr != NULL)
(*it).dataPtr += steps_to_shift;
memmove(first_packet_ptr + steps_to_shift, first_packet_ptr, shift_length);
1

